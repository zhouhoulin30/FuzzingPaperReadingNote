# TCP-Fuzz：Detecting Memory and Semantic Bugs in TCP Stacks with Fuzzing

# TCP-Fuzz：利用模糊测试检测TCP协议栈中的内存和语义bug

## 摘要

​		TCP协议栈在网络中提供了可靠的数据传输，因此，它们应该被正确地实现和测试，以确保可靠性和安全性。然而，测试TCP协议栈是困难的。首先，TCP栈接受彼此之间具有依赖性的数据包和系统调用，因此生成有效的测试用例是具有挑战性的。第二，TCP协议栈具有各种复杂的状态转移，但现有的测试方法旨在覆盖状态，而不是覆盖状态转移，因此其测试覆盖率是有限的。最后，我们对TCP协议栈的提交记录（commits）的研究表明，87%的bug修复提交记录都是与语义bug（如RFC违规）有关，但现有的bug清除程序（sanitizers）只能检测内存bug，而不能检测语义bug。

​		在本文中，我们设计了一个新颖的模糊测试框架，名为TCP-Fuzz，用于有效地测试TCP协议栈并检测bug。TCP-Fuzz包含三个关键技术：（1）基于依赖关系的策略，考虑数据包和系统调用之间的依赖关系，生成有效的测试用例；（2）一种基于转移引导的模糊测试方法，使用一种名为"分支转移"的新覆盖率指标作为程序反馈，以提高状态转移的覆盖率；（3）一种差分检测器，比较多个TCP协议栈对于相同输入的输出，以检测语义bug。我们已经在五个广泛使用的TCP协议栈（TLDK、F-Stack、mTCP、FreeBSD TCP和Linux TCP）上评估了TCP-Fuzz，并发现了56个真实的bug（包括8个内存bug和48个语义bug）。其中40个bug已经被相关开发人员确认。

## 1  介绍

​		TCP协议是一种传输层网络协议，它接收系统调用和数据包以提供可靠的数据传输。如今，它承载了超过85%的网络流量[44，63]。在实践中，TCP协议具有不同的实现，形成不同的TCP栈。每个现代操作系统（例如Linux和FreeBSD）都有自己的内核级TCP协议栈，为用户级应用程序提供基本的网络支持。此外，为了实现更好的性能并减少对操作系统内核的影响，许多用户级TCP协议栈（例如mTCP [26]、TLDK [59]和F-Stack [19]）已经被开发并广泛用于电信系统和网络节点中，以在没有操作系统参与的情况下传输数据。

​		尽管TCP协议栈至关重要，但正确实现它们是困难的[4,16]，因为TCP协议栈具有丰富的功能（如可靠的传输和拥塞控制）、复杂的状态模型以及各种可能需要处理的异常情况。因此，开发人员在实现TCP协议栈时可能会无意中犯错误，从而引入可能导致严重问题的bug。内存bug（如空指针解引用和使用已释放内存UAF）在TCP协议栈中很常见，它们可能导致程序崩溃、数据损坏等问题。此外，根据我们对TCP协议栈提交记录的研究，87%的bug修复提交记录与语义bug相关（例如RFC违规），这些bug与代码逻辑和RFC文档有关，而不是与内存访问有关。例如，CVE 2019-11478 [15]报告称，在处理某些TCP选择性确认（SACK）序列时，Linux TCP协议栈中的TCP重传队列可能会被分段，攻击者可以利用此漏洞造成拒绝服务。因此，测试TCP协议栈以检测bug是非常重要的。

​		为了检测TCP协议栈中的bug，一些方法[34、40、41、53]使用模型检查或形式验证来检查TCP实现的正确性。但是这些方法需要大量的手动工作和TCP特定的知识来提供完整和正确的TCP状态模型，并且由于TCP状态转移的高度复杂性，它们通常是非常耗时的。为了减少手动工作量和时间消耗，一些方法[9、30]对TCP协议栈源代码进行静态分析。但是由于缺乏准确的运行时信息，它们经常会引入误报。为了减少误报，一些方法[3-5、66]分析TCP协议栈的运行时跟踪以推断RFC违规行为。然而，它们需要大量且有效的测试用例以实现高覆盖率测试。

​		为了生成有效的测试用例，许多最近的方法对应用层网络协议的实现进行模糊测试，例如DTLS/TLS [17，52，54，60]，FTP [6，21，43]和Modbus [37，38]。但这些方法在测试TCP协议栈方面受到限制，重要原因有三个：（1）这些方法只生成数据包作为输入测试用例，而没有考虑输入之间的依赖关系；但是TCP协议栈接收系统调用(syscalls)和数据包，它们之间存在依赖关系。因此，这些方法在生成TCP协议栈的有效测试用例方面存在限制。（2）这些方法使用代码覆盖率作为程序反馈，以覆盖不同的协议状态；但是除了状态之外，TCP协议栈还具有各种状态转移，这些状态转移会严重影响TCP的执行并可能触发语义bug。因此，这些方法无法覆盖许多状态转移，因此可能会错过许多真实的bug。（3）这些方法中许多使用常见的漏洞检测器（例如ASan [2]和MSan [39]）来检测内存bug；但是TCP协议栈中的许多bug都是与内存访问无关的语义bug，因此常见的漏洞检测器无法发现这些语义bug。

​		在本文中，我们提出了一种新型的TCP协议栈模糊测试框架，名为TCP-Fuzz，它由三个关键技术组成。首先，为了生成有效的测试用例，TCP-Fuzz使用基于依赖的策略，可以通过考虑它们之间的依赖关系生成系统调用和数据包的序列。具体而言，这种策略考虑了三种依赖关系以生成有效的测试用例，包括系统调用-系统调用、数据包-数据包和系统调用-数据包依赖关系。例如，典型的数据包-数据包依赖关系是，新数据包的序列号应该等于前一个数据包的序列号和数据长度之和。其次，为了有效地覆盖状态转移，TCP-Fuzz采用了一种基于转移引导的模糊测试方法，该方法利用一种新的覆盖率指标称为分支转移来作为程序反馈，取代了代码覆盖率。分支转移被表示为一个向量，它存储了当前输入项（数据包或系统调用）的分支覆盖以及当前和前一个输入项之间分支覆盖变化的信息。这样，分支转移不仅可以描述状态，还可以描述相邻两个输入项之间的状态转移。最后，为了检测语义bug，TCP-Fuzz使用差分检测器来比较多个TCP协议栈对于相同输入的输出。实际上，不同的TCP协议栈应该遵守许多相同的语义规则（这些规则大多数在RFC文档中定义），因此它们应该为相同的输入产生相同或相似的输出。否则，这些TCP协议栈具有实现不一致性，表明其中一些可能存在语义bug。此检测器可扩展且不会为TCP协议栈引入运行时开销。

​		我们使用Clang [33]和Packetdrill [8]实现了TCP-Fuzz。TCP-Fuzz可以使用现有的漏洞检测器检测内存bug和使用我们的差分检测器检测语义bug。总体而言，我们做出了四个主要贡献：

- 我们研究了TCP协议栈提交记录，并发现87％的bug修复提交与语义bug有关，这些bug无法通过现有的漏洞检测器找到。我们还揭示了现有协议模糊测试在测试TCP协议栈时的局限性。
- 为了改进测试TCP协议栈的模糊测试，我们提出了三个关键技术：（1）一种基于依赖性的策略，考虑数据包和系统调用之间的依赖关系，生成有效的测试用例；（2）一种转移引导的模糊测试方法，使用一种名为“分支转移”的新覆盖率指标作为模糊测试反馈，以提高状态转移的覆盖率；（3）一种差检测器，用于比较多个TCP协议栈的相同输入的输出，以检测语义bug。
- 基于这三个关键技术，我们设计了一种名为TCP-Fuzz的新型模糊测试框架，用于有效地测试TCP协议栈。据我们所知，TCP-Fuzz是第一个系统性的TCP协议栈模糊测试框架，可检测内存和语义bug。
- 我们在五个广泛使用的用户级和内核级TCP协议栈（TLDK，F-Stack，mTCP，FreeBSD TCP和Linux TCP）上评估了TCP-Fuzz，并发现56个真实bug（包括8个内存bug和48个语义bug）。其中40个bug已被相关开发人员确认，23个bug已被修复。此外，我们还将TCP-Fuzz与现有的模糊测试方法（类似于AFL，Syzkaller，Boofuzz，Fuzzotron和AFLNet）进行比较，发现TCP-Fuzz找到了这些方法错过的许多真实bug。

​		本文其余部分的组织结构如下。第二节介绍了本文的研究背景和动机。第三节介绍了我们模糊测试TCP协议栈的关键技术。第4节介绍了TCP-Fuzz。第5节展示了我们的评估结果，并将TCP-Fuzz与现有的模糊测试工具进行了比较。第6节对模糊测试TCP协议栈进行了讨论。第7节介绍了相关工作，第8节总结了本文。

## 2  背景和动机

​		我们首先介绍了TCP协议栈，然后通过研究TCP协议栈的提交记录并揭示现有协议模糊测试在测试TCP协议栈方面的局限性来激发我们的工作动机。

### 2.1  TCP协议栈

​		TCP协议是一种经典的传输层协议，通过IP网络提供可靠的、有序的和错误检查的字节流传输。在实际应用中，TCP协议有不同的实现，形成了不同的TCP协议栈。除了经典的内核级TCP协议栈（如Linux TCP和FreeBSD TCP）之外，许多新的用户级TCP协议栈（如mTCP、TLDK和F-Stack）已经被开发并广泛使用，以实现更好的性能。然而，所有这些TCP协议栈都具有三个共同的特点：

[![ppDJpct.png](https://s1.ax1x.com/2023/03/25/ppDJpct.png)](https://imgse.com/i/ppDJpct)
[![ppDJ9jP.png](https://s1.ax1x.com/2023/03/25/ppDJ9jP.png)](https://imgse.com/i/ppDJ9jP)
[![ppDJPnf.png](https://s1.ax1x.com/2023/03/25/ppDJPnf.png)](https://imgse.com/i/ppDJPnf)

**F1：具有依赖关系的二维输入。**如图1所示，TCP协议栈接收来自网络驱动程序的数据包和来自应用程序的系统调用作为输入，并将系统调用的结果输出给应用程序以及响应数据包发送给网络驱动程序。与TCP相关的系统调用用于执行固定的网络功能。例如，系统调用`socket`用于创建通信的端点，并返回套接字的文件描述符；系统调用`accept`用于在套接字上接受连接，并返回套接字的新文件描述符。TCP数据包具有固定的格式，如图2所示，包括一个头和数据。TCP头由不同的字段组成，用于存储端到端TCP套接字的参数和状态。

​		TCP协议栈接受的数据包和系统调用之间应该具有依赖关系，否则它们将被TCP协议栈简单地忽略而没有深入处理。具体来说，有三种依赖关系：

- 系统调用-系统调用依赖。例如，当一个连接是被动打开时，应用程序必须按顺序调用一系列系统调用，包括socket、bind、listen和accept。否则，应用程序无法成功建立TCP连接。
- 数据包-数据包依赖。例如，在建立连接后，每个数据包的源端口和目的端口应该是固定的。否则，TCP协议栈会将这些数据包识别为无效的并直接丢弃它们，而不进行进一步处理。
- 系统调用-数据包依赖。例如，系统调用accept只有在TCP协议栈接收到三次握手中的最后一个数据包后才返回。

​		根据这一特性，在测试TCP协议栈时应满足两个要求。首先，需要生成系统调用和数据包的序列作为输入测试用例。其次，为了使测试用例更加有效，在生成测试用例时考虑数据包和系统调用之间的依赖关系非常重要。

**F2：状态模型。**TCP协议栈根据RFC 793 [50]文档中定义的基本状态模型工作。图3显示了这个基本状态模型，它有11个状态和20个状态转移。对于现实世界中的TCP协议栈，通常会有更多特定于TCP协议栈实现的状态和状态转移。

​		根据这个特性，当测试TCP协议栈时，尽可能多地覆盖状态和状态转移是很重要的。由于一个状态可以从不同的状态到达（例如，在图3中，TIME_WAIT可以从FIN_WAIT1、FIN_WAIT2和CLOSING到达），并且状态转移通常比状态多，因此在测试中覆盖状态转移实际上比覆盖状态更重要。

**F3：语义规则。**每个TCP协议栈都基于一些常规的语义规则工作，这些规则规定了如何处理系统调用和数据包。这些语义规则大多数都在RFC文件中明确描述。例如，RFC 7323文档[49]描述了如何处理TCP数据包头中的时间戳选项。在这个RFC文档中一个重要的语义规则是，一旦在TCP连接期间成功地协商了时间戳选项，TCP协议栈就应该只接受具有非递减时间戳的数据包；否则，TCP协议栈应该直接丢弃这些数据包。然而，一些语义规则并没有在RFC文档中明确描述。例如，RFC文档在TCP数据包报头中定义了32个可能的选项，并描述了应该如何处理这些选项[58]。但是对于未知选项，RFC文档没有描述如何处理它们。实际上，大多数TCP协议栈都忽略了这些选项。

​		根据这一特性，在测试TCP协议栈时，检查这些语义规则并检测相关违规是很重要的。事实上，这些违规与有问题的内存访问无关，因此我们将其称为语义bug。

### 2.2  TCP协议栈提交记录的研究

​		为了了解现有TCP协议栈中内存bug和语义bug的比例，我们选择了三个开源且广泛使用的TCP协议栈，包括FreeBSD TCP、mTCP [26]和TLDK [59]，以研究它们的提交记录。在这些TCP协议栈中，FreeBSD TCP是一个经典的内核级TCP协议栈；mTCP是学术界熟知的用户级TCP协议栈；TLDK协议是近年来产业界提出的一种用户级TCP协议栈，目前已被广泛部署在电信系统和网络节点。在我们的研究中，我们首先选择了2017年1月至2019年12月的bug修复提交，结果有201次提交；然后我们手动读取每个提交，以确定它是否修复了内存bug或语义bug。

[![ppDthtg.png](https://s1.ax1x.com/2023/03/25/ppDthtg.png)](https://imgse.com/i/ppDthtg)

​		表1显示了研究结果。87%的bug修复提交与语义bug有关，即TCP协议栈中报告的大多数bug都是语义bug。图4显示了一个修复FreeBSD TCP协议栈中语义bug的提交[14]示例。此提交的注释描述了它修复了RFC 7323 [49]的违规问题。具体来说，TCP协议栈错误地接受了时间戳值递减的数据包。为了修复这个bug，这次提交增加了几个关于时间戳值的检查，以丢弃无效的数据包。

[![ppDUtIO.png](https://s1.ax1x.com/2023/03/25/ppDUtIO.png)](https://imgse.com/i/ppDUtIO)

​		事实上，这些语义bug的引入主要有三个原因。首先，由于TCP协议栈具有丰富的功能和复杂的状态模型，开发人员在实现TCP协议栈时可能会无意中犯语义规则bug。其次，许多语义规则用于处理在正常执行中不经常发生的异常情况，因此与这些规则相关的代码在开发和测试中没有得到足够的重视。最后，在RFC文档中没有明确描述一些语义规则，因此开发人员无法确保他们实现的代码是否遵守这些规则。基于这些原因，在TCP协议栈中发现语义bug是至关重要的。

### 2.3  现有协议模糊测试的局限性

​		模糊测试是一种有效的运行时测试技术，在实践中已经展现出了优秀的漏洞检测能力。受到这些有希望的结果的鼓舞，许多最近的方法开始对应用层网络协议的实现进行模糊测试，例如DTLS/TLS [17, 52, 54, 60]、FTP [6, 21, 22, 43] 和 Modbus [37, 38]。然而，我们认为这些方法在测试TCP协议栈时受到了三个关键因素的限制：

​		1）无法生成具有依赖关系的二维输入。现有的模糊测试方法只生成数据包作为输入测试用例，而没有考虑输入之间的依赖关系。然而，如2.1节的F1所述，TCP协议栈接收系统调用和数据包，它们之间存在依赖关系。如果我们只生成数据包作为输入测试用例，那么很多关于处理系统调用的代码将无法被覆盖；如果我们忽略系统调用和数据包之间的依赖关系，许多生成的测试用例将毫无意义，并且在没有进行深入处理的情况下被TCP协议栈忽略，这会严重损害模糊测试的效率。因此，我们需要设计一种新的策略来生成有效的TCP协议栈测试用例。

​		2）忽略状态转移的覆盖率。现有的协议模糊测试方法使用代码覆盖率作为程序反馈来覆盖不同的协议状态。然而，第2.1节的F2所述，除了状态之外，TCP协议栈还有许多状态转移，它们严重影响TCP的执行。此外，覆盖相同状态的两个测试用例可能会覆盖不同的状态转移。例如，在图5中，测试用例T1按顺序覆盖状态S1、S2和S3，然后测试用例T2按顺序覆盖状态S1、S3和S2。T1和T2都覆盖了状态S1、S2和S3，因此现有的模糊测试方法将T2视为无用，因为它未能覆盖新状态。但是，T1和T2覆盖了不同的状态转移，即T1覆盖S1->S2和S2->S3，而T2覆盖S1->S3和S3->S2。因此，T2对于覆盖新的状态转移是有用的。

[![ppDav4S.png](https://s1.ax1x.com/2023/03/25/ppDav4S.png)](https://imgse.com/i/ppDav4S)

​		3）缺乏有效的语义bug检测。大多数现有的模糊测试方法使用常见的漏洞检测器（如ASan [2]和MSan [39]）来检测内存bug，例如空指针解引用和使用已释放的内存（UAF）等问题。然而，如2.2节所述，TCP协议栈中报告的大多数bug都是语义bug，这些bug不是由有问题的内存访问引起的。因此，这些漏洞检测器无法检测TCP协议栈中的语义bug。

## 3  关键技术

​		为了解决现有模糊测试在测试TCP协议栈时存在的局限性，我们提出了三种关键技术：基于依赖关系的策略生成有效的测试用例、基于状态转移引导的模糊测试方法来提高状态转移的覆盖率和差分检测器来检测语义bug。接下来我们将介绍这些技术。

### 3.1  基于依赖关系的策略

​		受到现有的用于文件系统的二维模糊测试方法[29, 64]的启发，我们生成包含系统调用和数据包的输入序列，作为TCP协议栈的测试用例。考虑到TCP协议栈所接受的数据包和系统调用之间存在许多依赖关系，我们设计了一种基于依赖关系的策略，以生成更有效的TCP协议栈测试用例。给定一个原始的输入序列，为了提高测试覆盖率，我们的策略对其进行变异以生成新的输入序列。如图6所示，对于原始输入序列中的每个项，**我们的策略首先选择变异类型，然后通过考虑与先前处理项的依赖关系对该项进行变异。**

[![ppDfG3n.png](https://s1.ax1x.com/2023/03/25/ppDfG3n.png)](https://imgse.com/i/ppDfG3n)

**变异类型的选择。**根据对系统调用或数据包可能进行的操作，我们的策略提供了五种可用的变异类型（包括删除、添加、替换和两种不同的更改），如表2所列。我们的策略随机选择一个变异类型按顺序处理输入序列中的每个项。因此，输入序列中的不同项可以使用不同的变异类型进行处理。

[![ppDh3VO.png](https://s1.ax1x.com/2023/03/25/ppDh3VO.png)](https://imgse.com/i/ppDh3VO)

**基于依赖关系的生成。**在表2中，除了删除操作，所有的变异类型都会在输入序列中生成一个新的系统调用或数据包。如2.1节中的F1所述，数据包和系统调用之间存在三种依赖关系。如果一个输入序列违反了这些依赖关系，TCP协议栈会将其视为无效并忽略。因此，为了生成更有效的测试用例，我们的策略考虑这些依赖关系来生成输入序列中的每个项。具体而言，在处理一个项时，我们的策略考虑该项与先前处理的项之间的依赖关系。目前，我们已经参考RFC文档（数据包-数据包和系统调用-数据包依赖关系）和系统调用使用规则（系统调用-系统调用依赖关系），实现了表3中的15个依赖规则。考虑到每个TCP协议栈都是根据RFC文档和系统调用使用规则实现的，我们相信这些依赖规则对于所有TCP协议栈都是通用的。

[![ppD5FNF.png](https://s1.ax1x.com/2023/03/25/ppD5FNF.png)](https://imgse.com/i/ppD5FNF)

​		需要注意的是，为了测试TCP协议栈是否正确遵守这些依赖规则，我们的策略还会有小概率地故意违反数据包-数据包和系统调用-数据包依赖规则，以生成一些异常的输入序列。实际上，这样的输入序列对于检测有关异常处理的RFC违规非常有用。

### 3.2  基于转移引导的模糊测试

​		如2.3节所述，代码覆盖率不能描述状态转移，因此我们的模糊测试方法需要一种新的覆盖率度量，可以有效地描述状态和状态转移。

​		对于给定的输入序列，当处理该序列中的每个项（一个系统调用或数据包）时，TCP协议栈的状态总是会发生改变。也就是说，每个这样的项都会影响TCP协议栈的执行情况。因此，在处理每个项后，TCP协议栈可以被认为达到了一个新的状态。这个状态可以用分支覆盖率（即代码分支的覆盖率）来描述，就像现有的模糊测试方法一样。因此，状态转移可以描述为由于两个相邻输入项而导致的两个覆盖状态之间的转移，即在这些输入项之间的分支覆盖率的变化。受到这个想法的启发，我们提出了一种新的覆盖率度量方法，称为分支转移，用于描述状态和状态转移。对于给定的输入序列，分支转移被表示为一个向量，该向量存储当前输入项的分支覆盖率以及当前和前一个输入项之间的分支覆盖率变化。

[![ppDTZcj.png](https://s1.ax1x.com/2023/03/25/ppDTZcj.png)](https://imgse.com/i/ppDTZcj)

​		图7通过一个例子说明了分支转移的概念。每个状态都用一个分支覆盖向量来描述，该向量包含TCP协议栈代码中每个分支的执行情况（是否已覆盖）。然后，当前输入项目与前一个输入项目之间的状态变化被表示为它们分支覆盖向量之间的差值（current − previous）。最后，当前输入项目的分支转移被表示为一个二维向量，其中包含它的分支覆盖向量和计算得到的差值向量。在图7(a)中，一个输入序列按顺序包含四个输入项，分别覆盖了状态S1、S2、S3和S1，因此它覆盖了三个不同的状态转移S1->S2、S2->S3和S3->S1。这些状态转移在图7(b)中描述为三个不同的分支转移。如果使用代码覆盖率，输入项3被认为是无用的，因为它覆盖了早先已经被输入项0覆盖的旧状态S1。然而，输入项3实际上覆盖了一个新的状态转移S3->S1，使用分支转移可以成功地描述它。

​		我们的模糊测试方法使用分支转移作为程序反馈，以有效地覆盖状态和状态转移。对于一个给定的输入序列，如果它覆盖了新的分支转移，我们的模糊测试方法将其识别为感兴趣的，并将其放入种子语料库中以供未来变异使用。然后，我们的模糊测试方法从种子语料库中选择一个种子输入序列，并使用我们基于依赖关系的策略对其进行变异以生成新的输入序列。我们参考AFL [1]实现了大部分的模糊测试过程。

​		事实上，除了分支转移外，状态转移还可以表示为最近几种模糊测试DTLS/TLS协议实现的方法所学习到的高级状态更改[17, 52]。然而，这些方法所学习的状态模型可能存在错误，因此仍需要大量的手动指导和验证以确保正确性。相比之下，通过收集TCP协议栈的运行时信息，可以自动而方便地获得分支转移。因此，我们的方法使用分支转移而不是这些方法所学习的更高级别的状态更改。

### 3.3  差分检测器



[![ppD7AVx.png](https://s1.ax1x.com/2023/03/25/ppD7AVx.png)](https://imgse.com/i/ppD7AVx)

​		为了检测语义bug，一个直观的解决方案是通过参考 RFC 文档中的语义规则来实现语义检测器。但是有很多 RFC 文档，而且一些语义规则甚至是隐含的，因此手动实现这些检测器很困难。实际上，不同的 TCP 协议栈应该遵循相同的语义规则（这些规则中的大多数定义在 RFC 文档中），因此它们应该为相同的输入产生相同或相似的输出。否则，这些 TCP 协议栈就存在实现不一致性，表明它们可能存在语义bug。

​		基于这个思路，受到最近差分测试方法 [11、12、65] 的启发，我们为 TCP 协议栈设计了一个差分检测器，用于检测导致输出不一致的语义bug。如图8所示，我们的差分检测器将相同的输入序列提供给多个 TCP 协议栈，然后记录它们的输出（包括系统调用的返回值和参数以及来自 TCP 协议栈的响应数据包），最后比较这些输出来识别和报告不一致性。用户可以检查这些不一致性以找到相关的语义bug。

​		为了提高发现语义bug的效率，我们建议在差分检测器中至少使用一个经典且经过充分测试的内核级TCP协议栈（例如Linux TCP或FreeBSD TCP）作为参考协议栈，用于测试较新的TCP协议栈。在这种情况下，如果我们的检测器报告了不一致，很可能是由于某个较新的TCP协议栈存在语义bug。

​		我们的差分检测器具有三个主要优势。首先，因为不同的TCP协议栈应该遵守相同的语义规则，因此对于相同的输入产生不一致的可能性并不大。因此，检查由我们的检测器所报告差异的手动工作应该比实现经过良好验证的语义规则检测器的工作少得多。第二，我们相信我们的检测器也有助于提取隐含的语义规则，通过识别和分析多个TCP协议栈的实现不一致性。最后，我们的检测器可扩展且不会为TCP协议栈引入运行时开销。

​		目前，我们的检测器记录并比较 TCP 协议栈的最终输出，而不记录和检查 TCP 协议栈在数据包传输期间的中间信息（例如窗口大小和数据包时间）。因此，它无法检测与拥塞控制和性能有关的语义bug。此外，我们的检测器检测多个TCP协议栈之间的输出不一致性，而不是在运行时检查特定的RFC文档。用户需要手动检查RFC文档并分析这些不一致性的根本原因，以确定与RFC违规相关的语义bug。

## 4  框架

[![ppDLe0A.png](https://s1.ax1x.com/2023/03/25/ppDLe0A.png)](https://imgse.com/i/ppDLe0A)

​		基于第三部分中的三种关键技术，我们提出了一个新颖的模糊测试框架，名为TCP-Fuzz，以有效地测试TCP协议栈并检测bug。我们使用Clang 9.0 [13]和Packetdrill [8]实现了TCP-Fuzz。具体而言，我们使用Clang对TCP协议栈代码进行代码插桩，以收集TCP协议栈执行过程中的覆盖分支；我们使用Packetdrill将生成的系统调用和数据包输入序列发送到TCP协议栈，并接收来自TCP协议栈的系统调用返回值和参数以及响应数据包。总体而言，TCP-Fuzz由四个部分组成：

**代码分析器。**它首先使用Clang将TCP协议栈的源代码编译成LLVM字节码。然后，它对LLVM字节码中的每个代码分支进行插桩。最后，它编译修改后的LLVM字节码以生成可执行的TCP协议栈。

**测试用例生成器。**它使用我们的基于转移的模糊测试方法和基于依赖关系的策略来生成系统调用和数据包的输入序列。每个这样的输入序列被表示为一个Packetdrill脚本，并通过Packetdrill提供给TCP协议栈。请注意，Packetdrill不支持发送违反表3中依赖规则的一些异常输入序列。因此，我们通过在其代码中放弃某些相关检查来修改Packetdrill，使其支持发送这些异常输入序列。

**运行时监视器。**它收集两种类型的运行时信息。首先，它收集覆盖的分支并计算分支转移以向我们的模糊测试方法提供反馈。其次，它调用Packetdrill接口来接收每个TCP协议栈的输出，并将它们提供给我们的差分检测器。

**bug检测器：**TCP-Fuzz拥有三种类型的bug检测器，用于检测内存bug和语义bug：

- 第三方漏洞检测器：现有的漏洞检测器如（ASan [2]和MSan [39]）通过在运行时监测内存访问来检测内存bug。
- 数据验证器： 我们实现了这个检测器来检测导致TCP协议栈不正确数据传输的语义bug，因为确保数据传输的正确性是TCP协议栈的基本属性。具体来说，这个检测器执行两种验证：（1）TCP协议栈通过调用read接收到的数据是否与发送到TCP协议栈的数据包中存储的数据相同；（2）通过调用write从TCP协议栈发送的数据是否与远端接收到的数据包中存储的数据相同。
- 差分检测器：该检测器用于比较多个TCP协议栈在相同输入下的输出，以便检测语义bug。

**部署。**如图10所示，TCP-Fuzz以服务器-客户端模式部署。通过这种方式，TCP-Fuzz不仅可以在每个TCP协议栈中使用第三方漏洞检测器和数据验证器来检测内存bug和数据正确性相关的bug，还可以在多个TCP协议栈中使用差分检测器来检测它们的语义bug。TCP-Fuzz服务器和客户端可以部署在同一台计算机上，并通过虚拟网络控制器相互通信；或者它们可以部署在不同的计算机上，并通过物理网络控制器相互通信。

[![ppy1qIg.png](https://s1.ax1x.com/2023/03/27/ppy1qIg.png)](https://imgse.com/i/ppy1qIg)

## 5  评估

### 5.1  实验设置

​		为了验证TCP-Fuzz的有效性，我们使用它来实际测试五个开源和广泛使用的TCP协议栈，包括三个用户级协议栈（TLDK，F-Stack和mTCP）和两个内核级协议栈（FreeBSD TCP和Linux TCP）。对于这三个用户级TCP协议栈，我们使用TCP-Fuzz的完整模糊测试过程对其进行测试。对于两个内核级TCP协议栈，因为它们是经典的且经过充分测试的，所以我们将它们用作差分检测器中的参考协议栈。此外，由于TCP-Fuzz目前只能插桩用户级程序，因此我们只使用从用户级TCP协议栈生成的测试用例来测试两个内核级TCP协议栈，而不使用反馈驱动的模糊测试。在未来，我们将实现内核代码插桩，以支持内核级TCP协议栈的完整模糊测试。

```C
反馈驱动的模糊测试（Feedback-driven Fuzzing）是一种模糊测试技术，其目标是优化模糊测试过程中的输入生成，使得生成的测试用例更能够触发程序中的漏洞。该技术的基本思想是，在每次生成输入之后，对程序的执行结果进行监控和分析，从而根据执行结果提供反馈，指导下一轮输入生成。这种反馈可以基于代码覆盖率、程序输出等信息。反馈驱动的模糊测试可以帮助测试人员在尽可能少的测试用例下找到更多的漏洞，从而提高测试效率和测试覆盖率。
```

​		表4显示了五个测试的TCP协议栈的基本信息。其中，FreeBSD TCP和Linux TCP是两个经典的内核级TCP协议栈，在很多机器上都有使用；mTCP是学术界熟知的用户级TCP协议栈；TLDK和F-Stack是工业界最新的两种用户级TCP协议栈，它们已经被广泛部署在电信系统和网络节点中。

[![ppytJq1.png](https://s1.ax1x.com/2023/03/27/ppytJq1.png)](https://imgse.com/i/ppytJq1)

​		我们在五台普通个人电脑上部署了TCP-Fuzz客户端，每台电脑上都运行一个要测试的TCP协议栈。我们在另一台个人电脑上部署TCP-Fuzz服务器，以生成测试用例并比较这些TCP协议栈的输出。对于每个用户级TCP协议栈，我们测试了48个小时；对于每个内核级TCP协议栈，我们通过输入从三个用户级TCP协议栈生成的测试用例进行测试。此外，我们运行第三方的漏洞检测器ASan [2]，以检测用户级TCP协议栈中的内存bug。

### 5.2  运行时测试

​		表5显示了模糊测试的结果，包括覆盖的分支和分支转移以及发现的内存bug和语义bug。请注意，TCP-Fuzz不会对两个内核级TCP协议栈进行插桩，因此它们的覆盖分支和分支转移没有被获取到。

[![ppyNW01.png](https://s1.ax1x.com/2023/03/27/ppyNW01.png)](https://imgse.com/i/ppyNW01)

**测试覆盖率。**TCP-Fuzz覆盖的分支转移比分支数量多得多，表明在执行过程中TCP协议栈有更多的状态转移而不是状态。图11显示了三个用户级TCP协议栈在模糊测试过程中覆盖的分支和分支转移的增长情况。与现有的基于代码覆盖率的模糊测试方法类似，TCP-Fuzz在后续测试中覆盖的新分支很少，但在这些测试中仍然覆盖了许多新的分支转移。

**发现的bug**。TCP-Fuzz在五个被测试的TCP协议栈中发现了56个真实的bug，包括8个内存bug和48个语义bug。我们向相关开发人员报告了这些bug，其中有40个已被确认。我们仍在等待剩余bug的响应（例如，mTCP的代码在Github上长时间没有更新，因此我们没有收到任何对我们在mTCP中报告的bug的响应）。此外，23个已确认的bug已被修复。

**输出不一致性。**TCP-Fuzz报告了五个测试TCP协议栈之间的15.1K个不一致性，我们通过对RFC文档的手动审查和对TCP协议栈执行的观察，分析其根本原因以识别语义bug。与SQLancer [51]和libFuzzer [32]类似，对于我们识别为语义bug的不一致性，我们使用开发人员的补丁或自己手动修复它们，以减少相关的不一致性。我们迭代地重复这个过程，直到不再出现不一致性，以统计独特的语义bug，结果为48个语义bug。我们观察到许多输出不一致性是重复的，因为它们由相同的根本原因触发。只有一个输出不一致性被认为是良性的。具体来说，当正常的数据包在FIN数据包之后到达，并且它们的序列号大于FIN数据包的序列号时，FreeBSD、F-Stack和mTCP会丢弃FIN数据包，而Linux TCP和TLDK会重置连接。由于RFC文档没有规定如何处理这种情况，我们不确定哪种策略是正确的。

**bug查找过程。**我们还分析了TCP-Fuzz如何发现这56个bug，并在表6中展示了结果。8个内存bug全都是由ASan发现的，2个语义bug是由数据验证器发现的，46个语义bug是由差分检测器发现的。结果表明，我们的差分检测器在发现语义bug方面是有效的。此外，我们还强调了数据验证器发现的2个语义bug非常危险，因为它们直接导致TCP协议栈发送或接收不正确的数据，严重破坏了数据传输的正确性。此外，28个bug是通过故意违反表3中列出的依赖规则生成的异常输入序列发现的，而另外28个bug是通过遵守这些规则生成的正常输入序列发现的。结果表明，TCP协议栈中处理异常输入的代码在实际应用中是容易出错的。因此，TCP协议栈中的异常处理应该在测试中得到更多关注。

[![ppy0HeJ.png](https://s1.ax1x.com/2023/03/27/ppy0HeJ.png)](https://imgse.com/i/ppy0HeJ)

**内存bug的根本原因。**在发现的8个内存bug中，2个是使用已释放内存（UAF）问题，3个是空指针解引用问题，2个是缓冲区溢出问题，1个是被零除问题。

[![ppyj6oQ.png](https://s1.ax1x.com/2023/03/28/ppyj6oQ.png)](https://imgse.com/i/ppyj6oQ)

**语义bug的根本原因。**对于发现的48个语义bug，我们在表7中总结了三个根本原因，并发现：

（1）33个语义bug是RFC违规，并且它们违反了表8中显示的8个RFC文档中明确描述的语义规则。例如，6个语义bug（TLDK中3个，mTCP中1个，F-Stack中1个，FreeBSD TCP中1个）是RFC 5961 [48]的违规行为。实际上，RFC 5961文档旨在通过改变重置数据包中可接受的序列号和正常数据包中确认号的范围来减轻盲窗攻击的影响[36]。因此，攻击者可以利用这些语义bug通过盲目窗口攻击重置连接[62]或注入恶意数据[7、10、45]。

（2）13个语义bug是由系统调用返回的不正确结果引起的。例如，3个语义bug（一个在TLDK中，一个在F-Stack中，一个在FreeBSD TCP中）是由于在按顺序调用listen和accept之后使用从socket获得的无效文件描述符而导致的。实际上，在调用listen和accept后，先前从socket获取的文件描述符变得无效，因此在使用此文件描述符时，ioctl、read和write应该返回一个错误代码。然而，TLDK、F-Stack和FreeBSD TCP在这种情况下返回零以表示成功，从而引发了语义bug。

（3）TLDK中的2个语义bug是由于违反了隐含的语义规则而引起的。具体来说，RFC文档没有描述如何处理TCP数据包头中的未知选项。在我们的测试中，F-Stack，mTCP，FreeBSD TCP和Linux TCP只是忽略这些选项并接受相关数据包，但TLDK在处理这些选项时会丢弃相关数据包或进入无限循环。

### 5.3  被发现bug的影响

​		我们手动审查了找到的56个bug，以估计它们对TCP协议栈的可靠性和安全性的影响。结果如表9所示。我们发现，关于RFC 5961违规的6个语义bug容易受到中间人攻击；9个bug（包括4个内存bug和5个语义bug）可能会导致数据损坏；8个bug（包括4个内存bug和4个语义bug）可能会导致崩溃或拒绝服务攻击；21个语义bug可能会导致数据通信的功能错误；12个语义bug可能会降低数据通信的效率。

[![ppyjydg.png](https://s1.ax1x.com/2023/03/28/ppyjydg.png)](https://imgse.com/i/ppyjydg)

​		图12展示了TCP-Fuzz发现的三个bug，包括1个内存bug和2个语义bug。该图还显示了TCP-Fuzz为查找这些bug而生成的Packetdrill脚本形式的相关测试用例。

[![pp6pdDx.png](https://s1.ax1x.com/2023/03/28/pp6pdDx.png)](https://imgse.com/i/pp6pdDx)

**TLDK中的释放后使用（UAF）问题。**在图12(a)中，函数`rx_fin`通过调用`empty_tq`释放`s->tx.q`的数据。然后，在函数`txq_rst_nxt_head`中访问`m->data_len`时使用了这些数据，从而导致了use-after-free问题。一旦触发了这个bug，攻击者就可以修改`s->tx.q`的数据，向TCP连接中注入恶意数据。为了修复这个bug，开发人员提交了一个补丁，在函数`rx_fin`中将`s->tcb.snd.una_offset`分配为零，以避免在函数`txq_rst_nxt_head`中访问`s->tx.q`的数据。

**FreeBSD TCP中的RFC 7323违规行为。**在图12(b)中，正如函数`syncache_expand`的注释所示，如果在三次握手的前两个数据包中未协商时间戳，FreeBSD TCP将拒绝包含时间戳选项的第三个数据包，并重置TCP连接。然而，RFC 7323文档规定，在这种情况下应该正常接受第三个数据包。一旦触发了这个bug，TCP连接可能在三次握手期间异常断开，导致功能错误。为了修复这个bug，开发人员提交了一个补丁，根据RFC 7323文件中相关的语义规则修改了有问题的代码。

**mTCP中的RFC 793违规。**在图12（c）中，如果当前数据包的序列号小于下一个预期的序列号，则mTCP丢弃当前数据包。然而，RFC 793文档规定，如果当前数据包与预期接收窗口的范围重叠，则应当接受该数据包。一旦触发此bug，数据通信可能会因异常丢弃数据包而效率低下。为了修复这个bug，我们的初步解决方案是在预期的接收窗口范围内接受当前数据包的内容。

### 5.4  与现有模糊测试工具的比较

​		我们以两种方式进行比较。首先，我们将TCP-Fuzz与两种经典且广泛使用的模糊测试方法进行比较，即AFL [1]和Syzkaller [57]。考虑到AFL和Syzkaller不能直接测试TCP协议栈，我们实现了一个类AFL和类Syzkaller的模糊测试工具进行比较。具体来说，类AFL工具通过考虑数据包之间的依赖性，仅根据代码覆盖率生成数据包序列；类Syzkaller的工具通过考虑系统调用之间的依赖性，仅根据代码覆盖率生成系统调用序列。这两个模糊测试工具使用TCP-Fuzz使用的三个bug检测器。其次，我们将TCP-Fuzz与三种最先进的开源协议模糊测试方法进行比较，即Boofuzz [6]，Fuzzotron [20]和AFLNet [43]。这三个模糊测试工具使用ASan来检测内存bug。在实验中，我们选择TLDK作为目标。实际上，TLDK包含TCP-Fuzz发现的所有bug的一半，因此与其他 TCP 协议栈相比，比较方法更有可能在 TLDK 中发现bug。

[![pp6g2pd.png](https://s1.ax1x.com/2023/03/28/pp6g2pd.png)](https://imgse.com/i/pp6g2pd)

**类AFL和类Syzkaller工具。**图 13 绘制了这两个模糊测试工具和 TCP-Fuzz 的覆盖分支转移情况。我们发现，TCP-Fuzz 比这两个模糊测试工具覆盖了更多的分支转移。这表明，生成二维测试用例（系统调用和数据包）比仅生成一维测试用例（系统调用或数据包）更有效地提高测试覆盖率。此外，我们还发现，类AFL工具比类Syzkaller工具覆盖了更多的分支转移，表明 TCP 协议栈的状态转移对数据包比对系统调用更敏感。此外，如图 14 所示，类AFL和类Syzkaller工具分别发现了7个和4个bug。TCP-Fuzz 发现了所有这些bug，并且由于覆盖更多的分支转移，它还发现了这两个模糊测试工具错过的 17 个bug。

[![pp6gcfH.png](https://s1.ax1x.com/2023/03/28/pp6gcfH.png)](https://imgse.com/i/pp6gcfH)

**现有的网络协议模糊测试工具。**如图 14 所示，Boofuzz发现了1个空指针解引用，而Fuzzotron和AFLNet没有发现任何bug。实际上，这三个模糊测试工具仅按照代码覆盖率生成数据包，而不考虑数据包之间的依赖关系。因此，由于测试用例生成和有限的程序反馈机制，它们错过了许多有用的状态转移。Fuzzotron和AFLNet主要用于测试应用层网络协议的实现，因此它们测试传输层 TCP 协议栈的能力较弱。TCP-Fuzz发现了Boofuzz发现的空指针解引用，并且由于使用第三部分中的三个关键技术，它还发现了27个bug（包括 1 个内存bug），而这三个模糊测试工具则错过了这些bug。

## 6  讨论

**差分检测器。**在我们的评估中，这个检测器报告了五个被测试的TCP 协议栈之间的15.1K个不一致性。我们本打算设计一个自动化工具来计算这些不一致性中独特的bug，但我们发现这样做有两个困难。首先，这些不一致性是从系统调用和数据包的输入序列中获得的，很难自动识别两个这样的序列是否具有相同的语义信息。其次，理解这些不一致性的根本原因需要 TCP 特定的知识，这些知识很难作为固定模式提取出来。

**测试拥塞控制。**拥塞控制是 TCP 协议栈的一个重要功能，但由于忽略与拥塞控制相关的数据包信息（例如每个数据包接受的数据长度）和代码信息（例如拥塞窗口大小的变量），TCP-Fuzz 目前无法对其进行测试。将来，我们将参考相关工作[27, 56]收集并检查这些信息，以测试 TCP协议 栈的拥塞控制实现。

**局限性和未来工作。**TCP-Fuzz在某些方面可以得到加强。首先，如5.1节所述，TCP-Fuzz在当前实现中无法对内核代码进行插桩，因此无法完全测试内核级TCP协议栈。为解决这个限制，我们计划在TCP-Fuzz中执行内核代码插桩或调整现有的基于虚拟机的方法[25，55]。其次，TCP-Fuzz在数据包传输过程中无法记录TCP协议栈的中间信息（例如窗口大小和数据包时间），因此无法检测有关拥塞控制和性能的语义bug。为解决这个问题，我们计划记录这种中间信息并实现相关的检测器来检测这些语义bug。第三，TCP-Fuzz无法检查并发内存访问，因此无法发现TCP协议栈中的并发bug。为解决这个限制，我们计划引入现有的并发分析方法[18，31]来检测TCP协议栈中的并发bug。最后，QUIC [46]是一种新的和有前途的传输层网络协议，预计将在未来取代TCP。因此，我们还计划将TCP-Fuzz扩展到测试QUIC实现。

## 7  相关工作

### 7.1  网络协议模糊测试

​		模糊测试是一种流行的测试技术，用于检测软件系统中的bug。人们已经提出了许多模糊测试方法来测试网络协议的实现。

​		一些方法[6，37，38，54，60]使用基于语法的模糊测试。它们利用硬编码或用户定义的语法规范来指导测试用例生成。这些规范定义了要生成的数据包的数据结构或字段类型。例如，TLS-Attacker [54]是一个灵活的TLS测试框架，供开发人员编写Java代码或基于XML的规范来测试其TLS实现。

​		最近的一些方法 [17, 43, 52] 采用了有状态的协议模糊测试。AFLNet [43] 可以学习网络协议的基本状态模型，以改进种子选择和变异。Fiterau-Brostean等人 [17] 通过扩展TLS-Attacker [54] 提出了一个实用工具，以学习多个DTLS实现的完整状态模型。通过比较这些学习的状态模型，用户可以推断DTLS实现中的bug。

​		然而，这些方法在测试TCP协议栈方面存在限制。首先，这些方法仅生成数据包作为测试用例，但是TCP协议栈接收的输入包括数据包和系统调用，因此这些方法可能会忽略很多处理系统调用的代码。其次，这些方法使用代码覆盖率作为程序反馈来覆盖状态，但是代码覆盖率不能有效地描述TCP状态模型中的状态转移。最后，许多这些方法仅使用现有的漏洞检测器来检测内存bug，但不能检测语义bug。为了解决这些限制，TCP-Fuzz使用基于依赖关系的策略生成数据包和系统调用的有效测试用例，使用转移引导模糊测试方法来改善状态转移的覆盖范围，并使用差分检测器来检测TCP协议栈的语义bug。

### 7.2  TCP协议栈检测

​		Packetdrill [8] 是一种脚本工具，用于测试网络协议栈的正确性和性能。用户可以编写类似 tcpdump 的脚本来生成和维护新功能开发和回归测试的测试用例。但是，以 Packetdrill 脚本的形式编写有效的测试用例需要对 TCP 协议栈有深入的了解和大量的手动工作。为了解决这个问题，TCP-Fuzz 根据程序反馈和数据包与系统调用之间的依赖关系自动生成 Packetdrill 脚本作为测试用例。

​		一些方法 [24, 34, 40, 41, 53] 执行TCP协议栈的模型检测或形式化验证。例如，Lockefeer等人 [34] 使用µCRL和LTSmin [35] 工具集生成状态空间，并对扩展了窗口缩放选项的TCP执行形式化验证。Hoque等人 [24] 使用符号执行来精确模拟带有符号输入的程序执行并探索所有可能的执行路径，并使用现成的模型检测器检测TCP协议栈的时间属性。但是这些方法需要大量的人工劳动和TCP特定的知识才能提供完整且正确的TCP状态模型，并且由于TCP状态转移的高复杂性，它们通常耗时很长。

​		一些方法[9，30]执行TCP协议栈源代码的静态分析。例如，PacketGuardian [9]使用静态污点分析检查各种网络协议实现的数据包处理逻辑，以检测数据包注入漏洞。然而，这些方法在实践中往往会引入误报，因为缺乏准确的运行时信息用于分析。

​		一些方法[3-5，66]分析TCP协议栈的执行轨迹以推断RFC违规行为。例如，Bishop等人[4]使用高阶逻辑规范分析执行轨迹，以识别多个网络协议协议栈之间的差异，从而检测可能的RFC违规行为。然而，这些方法需要大量且有效的测试用例才能实现高测试覆盖率。为解决这个问题，TCP-Fuzz使用模糊测试自动生成有效的测试用例。

​		一些方法[27, 28]进行TCP协议栈的运行时测试以自动发现攻击。这些方法策略性地生成数据包以覆盖不同的TCP状态，根据数据包信息和预定义的协议状态机进行跟踪，而不修改TCP协议栈代码。TCP-Fuzz与这些方法不同，它通过分支转移的指导生成数据包和系统调用作为测试用例；TCP-Fuzz不需要预定义的协议状态机，而是对TCP协议栈进行代码插桩以收集分支转移。

### 7.3  差分测试

​		为了发现语义bug，许多方法[11、12、23、42、47、61、65]执行差分测试，以识别相同功能的多个程序之间的实现不一致性。Classfuzz [12] 和 Classming [11] 在语法上变异 Java 字节码文件，并在不同的 JVM 实现上执行它们，以识别它们的不一致性。这两种方法都使用马尔科夫链蒙特卡罗（MCMC）抽样来引导变异器选择，以改善测试用例生成。C2V [65] 使用随机差分测试来检测代码覆盖工具（如 gcov 和 llvm-cov）中的bug。它随机生成程序代码文件，并比较代码覆盖工具的覆盖率报告以识别不一致性。受这些方法的启发，我们设计了一个有用的差分检测器来检测 TCP 协议栈模糊测试中的语义bug。

## 8  总结

​		本文中，我们开发了一种名为TCP-Fuzz的新型模糊测试框架，以有效测试TCP协议栈并检测bug。它使用了三项关键技术：（1）基于依赖关系的策略，考虑数据包和系统调用之间的依赖关系，生成有效的测试用例；（2）基于状态转移的模糊测试方法，使用分支转移作为程序反馈，以提高状态转移的覆盖率；（3）差分检测器，比较多个TCP协议栈相同输入的输出，以检测语义bug。我们在五个广泛使用的TCP协议栈上评估了TCP-Fuzz，并发现了56个真实的bug（包括8个内存bug和48个语义bug）。我们还将TCP-Fuzz与现有的模糊测试方法进行了比较，发现它发现了这些方法错过的许多真实bug。

​		在未来，我们计划改进TCP-Fuzz以检测拥塞控制问题和性能问题，并将TCP-Fuzz应用于其他TCP协议栈和QUIC的实现。