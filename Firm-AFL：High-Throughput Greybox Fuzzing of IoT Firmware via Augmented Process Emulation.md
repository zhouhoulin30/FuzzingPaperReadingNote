# Firm-AFL：通过增强进程模拟实现物联网固件的高吞吐量灰盒模糊测试

# Firm-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation

## 摘要

​		针对物联网设备的网络攻击是一个严重威胁。这些攻击利用物联网固件中的软件漏洞。模糊测试是一种对漏洞挖掘非常有效的软件测试技术。在本文中，我们介绍了FIRM-AFL，第一个用于物联网固件的高通量灰盒模糊器。FIRM-AFL解决了物联网模糊测试中的两个根本性的问题。首先，它通过启用模糊处理来解决可在系统仿真器中模拟的POSIX兼容固件的兼容性问题。第二，它使用一种称为增强过程仿真的新技术解决了系统模式仿真造成的性能瓶颈。通过以一种新颖的方式结合系统模式仿真和用户模式仿真，增强过程仿真提供了作为系统模式仿真的高兼容性和作为用户模式仿真的高通量。我们的评估结果表明：（1）FIRM-AFL功能完备且能够发现物联网项目中的真实漏洞；（2）FIRM-AFL的吞吐量平均比基于系统模式仿真的模糊测试高8.2倍；（3）FIRM-AFL能够比基于系统模式仿真的模糊测试更快地发现1-day漏洞，并且能够发现0-day漏洞。

## 1、介绍

​		物联网设备对我们生活的安全影响是巨大的。到2020年，连网的物联网设备数量将超过人口的数量。这造成了前所未有的攻击面，几乎所有人都处于危险之中。即使是当前，黑客也会利用缺乏安全性的物联网设备来创建大型僵尸网络（如Mirai、VPNFilter和Prowli）。这些恶意软件攻击利用物联网固件中的漏洞渗透到物联网设备中。因此，对防御者来说，发现物联网固件中的漏洞并在攻击者之前修复这些漏洞至关重要。

​		Fuzzing是一种为程序提供随机输入的软件测试技术，已被证明在发现真实程序中的漏洞方面非常有效。特别是，AFL，一种覆盖引导的灰盒模糊化工具，在工业界和学术界都得到了广泛应用。例如，DARPA网络大挑战赛的大多数决赛选手使用AFL作为主要的漏洞发现组件。

#### 物联网固件模糊测试的挑战

​		尽管对通用平台上的程序进行模糊测试是有效的，但直接在物联网固件上使用模糊测试通常是不可行的，因其对实际硬件配置具有强烈的依赖性。例如，在大多数情况下，仅仅从基于Linux的固件中提取一个用户级程序并用AFL对其进行模糊测试是行不通的。

​		为此，最近的研究提出了一系列解决方案，从直接模糊物联网设备（例如IoTFuzzer），一种结合硬件和软件仿真的混合解决方案（例如AVATAR），到全系统仿真（例如Firmadyne）。正如Muench等人最近的一项研究所指出的，全系统仿真产生了最高的吞吐量，因为物联网设备比桌面工作站或服务器慢得多。

​		吞吐量是模糊测试有效性的关键因素。然而，即使对于全系统仿真，其性能也远远不够理想。根据我们的评估（§5），全系统仿真比用户模式仿真（使用AFL）慢大约10倍。10倍的速度放缓意味着在物联网程序中发现漏洞所需的计算资源大约是桌面程序的10倍。根据我们的分析（§2.4），全系统仿真运行时的巨大开销一部分来自内存管理单元（即SoftMMU）的软件实现，针对虚拟机中发生的每一次内存访问，该内存管理单元用于将客户机虚拟地址转换为主机虚拟地址。另一部分开销来自系统调用仿真开销。

#### 我们的解决方案：通过增强过程仿真实现灰盒模糊。

​		在这项工作中，据我们所知，我们提出了第一个用于物联网固件的灰盒模糊器，它同时实现了两个设计目标：（1）透明性：固件中的程序不需要修改就可以进行模糊测试；（2）效率：整个系统的模糊吞吐量应该接近用户模式仿真的模糊吞吐量。我们的关键技术是找到全系统仿真和用户模式仿真的新组合，以实现两种技术的最佳效果：全系统仿真的通用性和用户模式模拟的效率。

​		更具体地说，我们提出了一种称为“增强过程仿真”的新技术。顾名思义，它的主要思想是用全系统仿真来增强过程（或用户模式）仿真。要模糊化的程序主要在用户模式仿真中运行以实现高效率，并且仅在必要时切换到全系统仿真以确保正确的程序执行，从而实现通用性。

​		为了评估该技术的可行性，我们在AFL和Firmadyne的基础上实现了一个名为FIRM-AFL的原型系统。从用户的角度来看，使用FIRMAFL，我们可以对来自物联网固件的一个用户指定程序进行覆盖率引导的灰盒模糊测试，这与使用AFL对正常用户级程序进行模糊测试相同。另一方面，FIRM-AFL偶尔会切换到Firmadyne中的全系统仿真模式，以确保给定的程序能够正确执行。

​		我们已经用标准数据和一组真实的物联网固件映像评估了Firm-AFL。评估结果表明：（1） FIRM-AFL可以正确地模拟目标程序，就像它们在全系统仿真中运行一样；（2）与基于全系统仿真的模糊器（启用了轻量级快照的TriforceAFL[29]）相比，FIRM-AFL的吞吐量平均高8.2倍；（3）在单个机器上FIRM-AFL发现1-day漏洞的速度比基于全系统仿真的fuzzer快3到13倍，并且能够在8小时内发现两个0-day漏洞。

#### 贡献

综上所述，我们在本文中作出了如下贡献：

- 我们发现，全系统仿真的运行开销很大，并且作为物联网固件模糊测试的基础并不理想。我们将进一步研究运行开销大的根本原因。
- 我们提出了一种名为“增强过程仿真”的新技术，以协调全系统仿真（高通用性和低效率）和用户模式仿真（低通用性和高效率）的矛盾特征。
- 我们为物联网固件设计并实现了第一个基于覆盖率引导的灰盒模糊器，FIRM-AFL。
- 我们对系统进行了全面的评估，并显示了系统每个部分的开销。我们的改进使得模糊测试的平均速度提高了8.2倍。因此，FIRM-AFL发现1-day漏洞的速度比基于全系统仿真的fuzzer快3到13倍，并且能够在8小时内发现两个0-day漏洞。
- 目前最新版本的FIRM-AFL支持三种CPU架构，包括mipsel、mipseb和armel，它们覆盖了Firmadyne数据表中90.2%的固件映像。FIRM-AFL的源代码已上传至Github： https://github.com/zyw-200/FirmAFL。

## 2、背景和动机

### 2.1 模糊测试

​		模糊测试是一种软件测试技术，旨在通过使用随机输入执行目标程序并寻找有趣的程序行为（如崩溃）来发现错误。根据从执行中收集和使用的信息量，模糊器可以分为黑盒、白盒和灰盒。黑盒模糊器将目标程序视为黑盒，不利用来自执行的任何反馈来指导随机输入的生成。这种方法最初用于测试Linux实用程序。另一方面，白盒模糊器基于对目标程序的深入了解来选择输入。这通常通过昂贵的程序分析技术实现，如动态污点分析和符号执行。最后，灰盒模糊器通过利用轻量级监控技术（例如代码覆盖率）收集的有限信息来改进测试。

​		最流行的灰盒模糊器是覆盖引导模糊器。这些模糊器检测目标程序以收集代码覆盖信息。然后，收集的信息用于指导输入生成——探索新执行路径的输入将被用作生成新输入的种子，而不产生新覆盖的输入将丢弃。这种简单的策略在实践中非常有效。事实上，灰盒模糊器甚至可以在针对真实应用程序时胜过白盒模糊器。他们的秘密是速度，轻量级的插桩允许灰盒模糊器执行比白盒模糊器多数百或数千倍的输入。换句话说，吞吐量对于灰盒模糊器来说至关重要。

​		AFL是一种著名的灰盒模糊器。它可以静态或动态地对程序进行插桩。当源代码可用时，首选静态插桩。当源代码不可用时，例如，当模糊商用（COTS）程序时，AFL使用二进制转换器（即QEMU提供的用户模式仿真）来执行插桩。事实上，即使从固件中提取二进制文件也并不总是简单的。

### 2.2 QEMU

​		QEMU是一种基于动态二进制转换的快速处理器仿真器。与逐个指令解释目标程序指令的传统仿真器不同，QEMU一次翻译几个基本块。更重要的是，它缓存翻译的块，并使用块链接将它们链接在一起。这使得执行能够在大部分时间内保持在代码缓存（即目标程序的逻辑）内，从而最小化了转换的开销。动态插桩可以在转换期间进行，以引入新功能，如分支监控和污点传播。

​		除了指令的翻译，下一个最重要的任务是地址空间转换。根据执行模式的不同，翻译的方式也十分不同。在系统模式下，QEMU实现了一个软件内存管理单元（MMU）来处理内存访问。软件MMU将客户机虚拟地址（GVA）映射到主机虚拟地址（HVA）。该映射过程对客户机操作系统（OS）是透明的，这意味着QEMU仍然允许客户机操作系统通过页表的接口来设置GVA到客户物理地址（GPA）映射，并处理页面错误。QEMU在内部为每次内存访问插入GVA到GPA的翻译逻辑。为了加速翻译，QEMU使用软件Translation Lookaside Buffer（TLB）来缓存翻译结果。此外，为了避免在地址转换更改时使代码缓存和块链无效，所有翻译块都使用GPA编制索引，并且仅在两个基本块在同一物理页面内时才执行块链接。GPA到HVA的映射是使用线性映射（即HVA=GPA+OFFSET）完成的。

```python
	TLB是转换查找缓存（Translation Lookaside Buffer）的缩写。它是一种高速缓存，用于缓存虚拟地址到物理地址的转换结果。当虚拟机试图访问某个虚拟地址时，QEMU会先检查TLB中是否有对应的物理地址，如果有，就直接使用TLB中的结果，从而加速内存访问的速度。
    在计算机系统中，代码缓存是用于保存执行的代码的缓存。块链是一种技术，用于将多个基本块（basic blocks）连接在一起，以便更快地执行代码。在上面的例子中，QEMU使用GPA来索引翻译块，以避免在地址转换更改时使代码缓存和块链无效。这意味着，只有当两个基本块在同一物理页面内时，才会执行块链。这有助于提高代码的执行速度。
```

​		与系统模式仿真相反，在用户模式仿真中，主机虚拟地址（HVA）是作为客户端虚拟地址（GVA）加上一个常数偏移量计算出来的。因此，这种转换比系统模式仿真中的转换要快得多。

```python
	在计算机系统中，模拟是一种技术，用于模拟另一种系统或设备的行为。在用户模式模拟中，虚拟机运行在用户空间，而不是内核空间。这意味着虚拟机只能访问用户空间的内存，而不能访问内核空间的内存
```

### 2.3 测试IoT固件

​		随着物联网设备成为流行的攻击目标，测试物联网程序以发现漏洞也变得重要。测试物联网程序有两个主要挑战。第一个挑战是兼容性：许多物联网程序依赖于设备的特殊硬件组件，因此在没有适当支持的情况下无法进行测试。第二个挑战是代码覆盖率：众所周知，黑盒模糊器的代码覆盖率很低，而白盒模糊器无法扩展到稍大的代码库。表1比较了使用这两个指标进行物联网固件测试的一些代表性工作。

​		Avatar旨在通过提供更好的硬件组件支持，实现嵌入式固件的动态程序分析。它是通过构建一个混合执行环境来实现的，该环境由处理器模拟器（QEMU）和真实硬件组成，其中Avatar作为模拟器和真实硬件之间的软件代理。这使得Avatar能够使用模拟器执行和分析指令，同时将I/O操作转发到物理硬件。作为演示，作者已将S2E应用于寻找Redwire Econotag Zigbee传感器的漏洞，这是一种白盒模糊测试工具。由于涉及白盒模糊测试和慢速硬件，预计Avatar的吞吐量将非常低。

​		IoTFuzzer直接在真实设备上进行黑盒模糊测试。与先前基于黑盒模糊测试的方法相比，它的主要优势在于，它通过目标设备的配套移动应用程序来进行模糊测试。通过自动分析配套应用程序中的数据流来更好地了解通信协议，IoTFuzzer可以生成更好的测试用例，这些测试用例更容易触发bug。尽管如此，根据其评估，IoTFuzzer的吞吐量从未超过每秒1个测试用例，这是很慢的（基于[14]中表III）。

​		尽管不进行模糊测试，但Firmadyne在系统模式QEMU中添加了对IoT固件的硬件支持。它支持物联网制造商流行的ARM和MIPS架构。对于硬件支持，Firmadyne通过修改内核和驱动程序来处理由于缺乏实际硬件而导致的IoT异常，从而完全模拟系统。与前两种解决方案相比，该解决方案更易于适应新的IoT固件和程序。全系统仿真的吞吐量通常优于本地执行。

​		Muench等人比较了不同配置下黑盒模糊器的吞吐量，包括本机执行（直接向硬件发送输入）、部分仿真（仅将硬件请求重定向到硬件）和完整仿真。它们的仿真基于PANDA提供的图像重放功能。他们得出结论，完全仿真（FE）具有最高的吞吐量，这主要是因为物联网处理器比桌面处理器慢得多。然而，即使在最佳情况下，吞吐量也没有超过每秒15个测试用例。

```python
	图像重放功能是指在软件模拟器（如PANDA）中，能够将系统的运行状态记录下来，并允许在将来按照记录的状态重新执行。 这个功能类似于计算机中的快照功能，可以方便软件测试人员在模拟器中快速回放系统的运行状态。 在软件模拟器中使用图像重放功能可以节省许多手动测试的时间，并且可以方便地进行测试自动化。
```

​		AFL是一个著名的灰盒模糊测试器，可以通过用户模式 QEMU 支持仅二进制模糊测试。不幸的是，由于缺乏特殊的硬件支持，用户模式QEMU无法成功模拟大多数IoT程序。例如，使用用户模式QEMU的AFL在我们评估中使用的所有程序上都失败了（表3）。此外，仅仅采用全系统仿真器（例如Firmadyne）并不能完全解决问题，因为吞吐量很低。

[![zqmRF1.png](https://s1.ax1x.com/2022/12/18/zqmRF1.png)](https://imgse.com/i/zqmRF1)

​		总的来说，现有的物联网固件测试工具尚未提供令人满意的代码覆盖率，而最先进的模糊测试工具（例如，AFL）也不能轻松应用于测试物联网程序。到目前为止，还没有灰盒 IoT 模糊测试工具，更不用说具有良好吞吐量的灰盒 IoT 模糊测试工具了。

### 2.4 动机

​		鉴于物联网固件测试工具的现状令人不满意，我们的目标是实现物联网程序的高通量灰盒模糊测试。为此，我们决定基于仿真构建模糊器。这种选择基于两个原因。首先，灰盒模糊测试需要收集执行信息（例如，分支覆盖率）以指导测试用例生成。如§2.1所述，这通常通过轻量级插桩完成。由于大多数IoT程序仅以二进制格式分发，因此基于仿真器的插桩是最好的选择。第二个原因是性能。尽管有可能直接在设备上运行插桩后的二进制文件，但Muench等人已经表明，基于完全仿真的方法实际上比真实设备更快，因为桌面处理器更快。

​		遗憾的是，仅仅一个采用全系统模拟器（例如Firmadyne）并不能完全解决问题，因为吞吐量不够。例如，即使使用完全仿真配置，[28]中使用的模糊器每秒也从未超过15个测试用例。为了了解瓶颈，我们分析了两种网络工具（basename和uptime）在全系统仿真（使用轻量级快照）和用户模式仿真下的执行时间。结果如表2所示。基于这一测量，我们可以发现，如果我们可以将用户模式仿真应用于目标程序，那么模糊测试的吞吐量可以显著提高。有几个瓶颈问题导致了执行时间差异。

#### B1.内存地址转换

​		在全系统仿真中，QEMU使用软件MMU对每次内存访问执行地址转换。相比之下，在用户模式仿真中，地址转换要简单得多。因此，即使我们只考虑在用户模式执行中花费的时间，用户模式仿真所用的时间也要少得多。

#### B2.动态代码翻译

​		用户模式仿真中的代码翻译过程比全系统模式更快。在全系统模式下，块链的范围仅限于同一物理页面中的基本块，这意味着翻译器比在用户模式仿真中调用更频繁。

#### B3.系统调用模拟

​		在用户模式仿真中，系统调用由主机操作系统和硬件直接处理。因此，它比全系统仿真快得多，而在全系统仿真中，操作系统也在模拟器中运行，硬件设备也被模拟。尽管硬件仿真是允许目标程序正确运行所必需的，但并非所有系统调用都依赖于特殊硬件。换句话说，并非所有系统调用都需要模拟。在本文中，我们解决了三个影响IoT程序模糊测试吞吐量的瓶颈问题。

[![zXytIg.png](https://s1.ax1x.com/2022/12/22/zXytIg.png)](https://imgse.com/i/zXytIg)

## 3、增强进程模拟

### 3.1 概述

​		这项工作的目标是设计一个专门用于IoT程序的高吞吐量灰盒模糊器。如§2中所述，为了实现这一目标，我们需要克服两个挑战：兼容性和性能。第一个挑战可以通过全系统仿真来解决，但这将导致较差的性能。第二个挑战可以通过用户模式仿真来解决，但会导致较差的兼容性。在本节中，我们将介绍增强进程模拟，这是一种新的方法，它同时拥有全系统仿真和用户模式仿真的优点。

#### 问题陈述

​		一般来说，增强进程模拟的目标是在用户模式仿真器中正确运行IoT固件的程序，并要满足以下要求：

​		（1）固件可以在系统仿真器（例如，系统模式QEMU）中正确仿真。幸运的是，在Firmadyne的帮助下，大部分物联网固件映像能够满足这一要求。

​		（2）固件为POSIX兼容的操作系统。幸运的是，许多IoT固件映像使用Linux作为操作系统，因此满足了这一要求。

​		通过增强进程模拟，我们将实现如下设计目标：

##### 透明性

​		用户级程序在增强进程模拟中运行的表现应该与在系统模式仿真中运行一样。

##### 高效性

​		由于吞吐量是模糊测试的主要因素，因此增强进程模拟需要尽可能高效。由于吞吐量是模糊化的主要因素，因此增强过程仿真需要尽可能高效。

#### 解决方案概述

​		为了实现上述设计目标，我们采用一种新颖的方式将用户模式仿真与系统模式仿真相结合。图1阐述了我们的方法。

​		首先，IoT固件在系统模式仿真器中启动，用户级程序（包括要模糊测试的程序）在仿真器中正确启动。当待模糊的程序已经到达预定点（例如，main函数的入口点，或者在接收到第一个网络分组之后）之后，进程的执行被迁移到用户模式仿真，以便获得高的执行速度。只有在极少数情况下，执行才会迁移回系统模式执行，以确保执行的正确性。

​		为了最小化迁移成本，内存状态会在这两种仿真模式之间共享。更具体地来说，用于系统模式仿真的虚拟机的物理内存被分配为一个内存映射文件（称为RAM文件）。该RAM文件也映射到用户模式仿真的地址空间。请注意，系统模式仿真和用户模式仿真会以不同的方式访问此RAM文件。系统模式仿真将RAM文件视为物理内存，因此通过物理地址访问它，而用户模式仿真通过虚拟地址访问共享内存。因此，**RAM文件中的物理页面需要按页面粒度通过其虚拟地址映射到用户模式仿真的地址空间中。**因此，当在用户模式仿真中未建立页面映射时，需要将流程执行迁移到系统模式仿真以建立此映射。我们将在§3.2中讨论有关内存映射的更多细节。

​		在到达系统调用之前，只要有适当的内存映射，进程就能在用户模式仿真中正确执行。直接在主机OS上本地执行系统调用通常不起作用，因为主机OS和IoT固件中的OS不同，底层硬件层也不同。为了确保透明性，我们需要将执行迁移到系统模式仿真以处理此系统调用。当系统调用返回时，我们将执行迁移回用户模式仿真。更多细节将在§3.3中讨论。

### 3.2 内存映射

#### 引导

 		当用AFL对程序进行模糊测试时，程序执行到一个预定的点，然后AFL的fork服务器将在这个点上重复fork一个新的程序实例（称为fork point），并提供随机输入。同样，在此设置中，我们将在系统模式仿真中启动IoT固件，并进一步启动指定的IoT程序。使用DECAF（基于系统仿真的动态分析平台）提供的虚拟机自省（VMI），我们能够监控指定物联网程序的执行，并在执行到达预定点时得到通知。

​		此时，我们将遍历指定进程的页表，收集虚拟到物理页映射信息，并将其发送到用户模式仿真端。然后对于每次虚拟地址（va）到物理地址（pa）的映射，用户模式仿真端通过如下调用mmap来建立映射：

```python
mmap(va, 4096, prot, MAP_FILE, ram_fd, pa);
```

​		上述代码顾名思义。本质上，我们将一个RAM文件页面的物理地址作为偏移量映射到指定的虚拟地址。参数prot由对应的页表项的保护位确定。

​		从这一点开始，系统模式仿真中的运行被暂停，CPU的状态被发送到用户模式仿真，然后在那里继续执行。

#### 页面错误处理

​		在用户模式仿真进程执行期间，如果访问的内存地址已经映射到此地址空间中，则执行不会出错。否则，主机处理器将引发页面错误。我们在用户模式仿真中为页面错误注册了一个信号处理程序，因此主机操作系统会将页面错误事件传递给用户模式仿真。在接收到该信号时，用户模式仿真记录错误指令处的CPU状态，暂停执行，并将CPU状态传递给系统模式仿真侧，期望可以在系统模式仿真中处理页面错误，并且可以建立错误虚拟地址的新映射。

​		当系统模式仿真接收到CPU状态并恢复执行时，由于页面不存在，仿真处理器将引发页面错误。IoT固件操作系统中的页面错误处理程序将响应此页面错误并尝试建立映射。大多数情况下，这个映射迟早会由OS建立（取决于许多内核线程和中断处理程序的调度），导致页面错误的指令将被重新执行。在极少数情况下，如果操作系统由于各种原因无法建立映射，则会终止进程。

​		这里的一个关键问题是确定页面映射何时建立或发生错误，这样我们就可以切换回用户模式仿真以最大化执行速度。这个问题的答案实际上很简单，因为操作系统同时处理多个任务，同时可能会发生大量的上下文切换。

​		为了捕捉建立映射时的正确时刻，我们在每个基本块的末尾插桩。如果执行当前在指定的进程（或线程）内，则意味着执行已从内核返回到用户空间以恢复错误指令。该映射必须在TLB中存在，以便我们可以直接找到这个映射。此时，我们将映射信息和CPU状态传递回用户模式仿真，用户模式仿真将通过调用mmap创建新映射并继续执行。

​		如果由于某些原因，发生错误并终止进程，我们可以依靠DECAF提供的VMI（虚拟机自省）功能获得通知，然后终止双方的整个执行。

#### 预加载页面映射

​		现代操作系统以惰性方式加载内存页。尽管当一个新进程启动时，所有代码页都被分配到其地址空间中，但直到对每个虚拟页的第一次内存访问导致页面故障，才真正建立从每个虚拟页到其物理页的映射。

​		这种懒惰的设计对模糊性能有不利影响。正如我们将在§4.1中讨论的，每个模糊迭代的子进程都重复地从父进程派生出来，因此总是会有一系列由未映射的代码页导致的页面错误。这对我们的系统尤其有害，因为页面错误处理的开销比在主机操作系统上本地处理要大得多。

​		为了解决这个问题，我们决定在物理内存中预加载给定进程的代码页，并执行两种模式之间的映射。这有助于我们避免在每次模糊迭代时重复加载代码页，从而加快模糊吞吐量。为此，我们在引导过程期间模拟系统模式仿真中对每个代码页的访问，以迫使OS将每个页面映射到进程的地址空间中。从而我们可以减少这些预加载页面导致的页面错误的数量。

### 3.3 系统调用重定向

​		IoT程序中的系统调用及实现会因为底层硬件、固件和需求的不同而不同。因此，如果没有正确的处理由系统调用引起的异常，用户模式仿真下的IoT程序可能会崩溃（见2）。例如，大多数物联网设备的网络接口在本地仿真器上不可用。当用户模式仿真中的IoT程序执行需要与IoT系统中特定网络接口进行交互的系统调用时，将出现需要处理的故障。另一个例子是访问桌面计算机未定义的NVRAM的系统调用。

​		因此，为了确保执行的正确性，我们必须将系统调用从用户模式仿真重定向到系统模式仿真。更具体地说，当用户模式仿真遇到系统调用时，它会暂停执行，保存当前CPU状态，并将其发送到系统模式仿真。系统模式仿真接收CPU状态并恢复执行。这将导致客户系统中的模式切换到内核模式，以处理相应的系统调用。同样，由于客户OS内核是多任务的，在系统调用返回之前可能会发生许多上下文切换。因此，与我们处理页面错误的方式类似，我们将在每个基本块的结尾插桩。如果当前基本块在内核空间中，但下一个程序计数器在用户级别，并且当前执行上下文是用于进行系统调用的线程，则我们检测系统调用返回的时刻。此时，我们暂停系统模式仿真中的执行，保存CPU状态，并将其传递回用户模式仿真，然后用户模式仿真将继续执行。

#### 优化与文件相关的系统调用

​		在检查由IoT程序发出的系统调用时，我们发现许多系统调用与文件系统相关。IoT程序要么尝试访问固件中已经存在的文件或目录，要么是新创建的仅供临时使用。我们建议对这组系统调用进行优化。我们从固件映像映射文件系统，并将其作为一个目录安装在主机操作系统中，以便用户模式仿真可以直接访问它。这样，用户模式仿真可以直接将与文件系统相关的系统调用传递到主机OS，而不是将它们重定向到系统模式仿真。

​		如§5.3所示，与文件系统相关的系统调用在所有系统调用中占很大一部分，因此这种优化对最终性能做出了重要贡献。

## 4、Firm-AFL设计与实现

​		利用§3中描述的技术，我们设计并实现了FIRM-AFL，这是AFL的增强，用于模糊物联网固件。在§4.1中，我们首先描述了AFL的工作流程，然后在§4.2中，我们介绍了如何将增强过程仿真集成到AFL的工作流中。

### 4.1 AFL工作流程

​		AFL是一种覆盖引导的灰盒模糊器。它维护一个种子队列，该队列存储所有种子，包括用户选择的初始种子，以及从现有种子中变异的种子，从而使程序的代码覆盖率最大化。

​		启动模糊测试进程的主程序是afl-fuzz。它从种子队列中选择一个种子，执行随机变异，生成一个输入，并将该输入馈送到目标程序（假设它是二进制可执行文件）。

​		为了从目标程序的执行中收集代码覆盖信息，AFL使用用户模式QEMU启动程序，并对目标程序的分支转换进行插桩检测，代码覆盖信息被编码并存储在位图中。

​		由于在模糊化过程中，我们需要重复执行目标程序，AFL利用“fork”作为一种机制来加快这个过程。它首先将目标程序运行到某个点（例如，主函数的入口点），以使程序的代码和数据已正确初始化，然后从中重复派生子进程。这样，就跳过了新进程的初始设置。因此，父进程称为fork-server。然后，输入被馈送到派生出的子进程，覆盖信息被收集并存储在位图中，位图在所有三个进程（afl-fuzz、fork-server和子进程）之间共享。afl-fuzz将比较来自子实例的位图和来自所有过去执行的累积位图，以确定该变异输入是否应作为新种子保存并存储在种子队列中。

### 4.2 带有增强进程模拟的AFL

​		我们希望保持AFL的工作流程不变，但允许AFL模糊物联网固件映像中的目标程序。为此，我们将用户模式QEMU替换为增强的过程仿真，其余组件保持不变。新的工作流如图2所示。

[![zvjX1H.png](https://s1.ax1x.com/2022/12/25/zvjX1H.png)](https://imgse.com/i/zvjX1H)

#### 引导

​		要模糊IoT固件映像中的程序，我们需要启动固件映像，并在系统启动后启动程序。这是在fork-server中的系统模式仿真中完成的。

​		我们利用Firmadyne正确模拟固件映像。我们进一步将DECAF与Firmadyne集成，以利用其VMI（虚拟机自省）功能。通过这种方式，我们能够捕捉目标程序启动或终止的精确时刻。我们还可以知道目标程序的执行何时达到了预定的分支点。

#### 分支

​		AFL选择的默认分叉点是主函数的入口点。在我们的案例中，我们希望通过网络接口触发的IoT程序中的漏洞。因此，我们会hook网络相关的系统调用。当这些系统调用函数被第一次调用时就会创建分支点。

​		在AFL的标准工作流中，我们可以简单地利用fork系统调用来派生子进程并启动下一个模糊测试实例。在我们的例子中，我们不仅需要为用户模式仿真派生一个子进程，还需要为系统模式仿真“派生”一个新的虚拟机实例，因为两种模式必须相互同步。

​		事实上，创建一个虚拟机需要的系统资源太多。相反，我们可以在分叉点创建虚拟机的快照，当一次模糊执行完成时，我们可以恢复快照。系统模式QEMU提供save_snapshot函数，将所有CPU寄存器和内存空间保存到特定文件。但是，文件写入/读取操作仍然非常缓慢。

​		在我们的系统中，我们基于写时复制原则实现了一种轻量级快照机制。更具体地说，我们首先将映射到系统模式QEMU的RAM文件标记为只读。那么内存写入将导致页面错误。我们复制该页，然后将该页标记为可写。因此，我们记录在一次模糊执行期间修改的所有内存页。恢复快照时，我们只需要将这些记录的页面写回。

#### 样本输入

​		输入是通过检测系统调用提供的。对于从网络接口接收输入的IoT程序，我们直接在用户模式仿真中检测网络相关系统调用，因此我们不需要将这些系统调用重定向到系统模式仿真。

#### 收集覆盖信息

​		由于大多数执行都发生在用户模式仿真中，而系统模式仿真仅用于处理页面错误和一些系统调用，因此我们可以简单地在用户模式QEMU中插入分支转换，以计算覆盖位图，就像原始AFL在用户模式QEMU中的操作一样。