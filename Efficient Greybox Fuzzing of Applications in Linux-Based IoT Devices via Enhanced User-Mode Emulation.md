# Efficient Greybox Fuzzing of Applications in Linux-Based IoT Devices via Enhanced User-Mode Emulation

# 通过增强的用户模式仿真对基于Linux的物联网设备中的应用程序进行有效的灰盒模糊测试

**Zheng Y, Li Y, Zhang C, et al. Efficient greybox fuzzing of applications in Linux-based IoT devices via enhanced user-mode emulation[C]//Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis. 2022: 417-428.**

**From  ISSTA  2022**

## 摘要

​		灰盒模糊测试已成为最有效的漏洞发现技术之一。然而，灰盒模糊技术并不能直接应用于物联网设备中的应用。主要原因是执行这些应用需要高度依赖于特定的系统环境和硬件。为了在基于Linux的物联网设备上执行应用程序，大多数现有的模糊测试技术使用全系统仿真来最大化兼容性。然而，与用户模式仿真相比，全系统仿真的开销很大。因此，一些先前的工作，例如Firm-AFL，建议将全系统仿真和用户模式仿真相结合，以加快模糊测试过程。尽管尝试将应用程序转向用户模式仿真，但现有技术不支持在用户模式仿真中完全执行这些应用程序。

​		**为了解决这些问题，我们提出了EQUAFL，它可以自动设置执行环境以在用户模式仿真下执行嵌入式应用程序。EQUAFL首先在全系统仿真下执行应用程序，并观察在用户模式仿真期间程序可能会卡住甚至发生崩溃的关键点。通过观察到的信息，EQUAFL可以迁移用户模式仿真所需的环境。然后，EQUAFL使用一个增强型用户模式仿真来重放网络的系统调用和资源管理行为，以满足嵌入式应用程序在执行过程中的需求。**

​		我们在70个来自不同系列物联网设备的网络应用程序上评估了EQUAFL。结果表明，EQUAFL在模糊测试效率方面优于现有技术（平均而言，全系统仿真比AFL-QEMU快26倍，比Firm-AFL快14倍）。我们还从测试的固件映像中发现了10个漏洞，包括6个CVE。

## 关键词

灰盒模糊测试，基于Linux的物联网设备，增强用户模式仿真。

## 1、介绍

​		随着物联网（IoT）的快速发展，数十亿的物联网设备连接到互联网。与传统IT供应商相比，物联网设备的供应商更注重系统功能，而不是系统安全。因此，物联网系统中运行的应用程序存在各种未知漏洞，为攻击者提供了大量攻击面。例如，2016年底，Mirai病毒被开发出来，旨在利用基于Linux的物联网设备漏洞，在美国东海岸发起大规模DDoS攻击。这一事件对网络空间安全产生了重大影响。总之，安全研究人员需要尽快发现基于Linux的物联网设备内部的漏洞，尤其是那些在物联网设备和互联网之间扮演着“大门“角色的应用程序。

​		灰盒模糊是一种实用的软件漏洞检测技术。灰盒模糊测试的基本思想是使用轻量级程序插桩来收集被测程序（PUT）的执行反馈，例如代码覆盖率，以指导整个测试过程。尽管灰盒模糊测试在桌面环境中运行的常规程序上表现出良好的性能，但它并不能直接应用于在嵌入式设备中运行的程序。这主要是因为缺少用于执行应用程序的系统和硬件支持。为了解决这个问题，现有的灰盒模糊技术使用仿真技术来执行嵌入式应用程序。

​		现有的仿真技术，如QEMU，支持用户模式仿真和全系统仿真。与全系统仿真相比，由于无法模拟系统调用和执行上下文，用户模式仿真以兼容性为代价，执行开销要小得多。因此，大多数现有的灰盒模糊技术使用全系统仿真来执行嵌入式应用程序。然而，由于仿真整个系统的开销很大，这种方法存在效率低下的问题。为了提高效率，最近的一项工作，Firm-AFL，提出了一种在用户模式仿真和全系统仿真之间智能切换的技术。Firm-AFL的机制是，只要应用程序不执行系统调用，它就允许应用程序在用户模式下运行；每当应用程序遇到一个系统调用时，Firm-AFL就会切换到全系统仿真以获取系统调用结果。与全系统仿真相比，Firm-AFL提高了执行速度，但当被测程序涉及大量系统调用时，这种改进变得微不足道。**因此，现在的挑战是，我们能否在用户模式仿真下完全执行嵌入式应用程序，而不牺牲太多兼容性？**

​		为了解决在基于Linux的物联网设备中对应用程序进行模糊测试的挑战，我们提出了EQUAFL，一种通过增强型用户模式仿真来扩展的灰盒模糊测试框架，该框架同时具有很高的效率和很高的兼容性。增强型用户模式仿真的基本机制是自动设置执行环境，以便被测程序的系统调用可以直接传递到主机。通过这种方式，被测程序可以在用户模式仿真中完全执行，避免了通过仿真系统调用所产生的开销。**为了自动设置被测程序的执行环境，EQUAFL使用观察—重放策略。首先，EQUAFL通过全系统仿真执行被测程序，并观察系统的关键行为，如设置启动变量，生成配置文件，网络操作等等。然后，EQUAFL将会重放观察到的系统行为，来建立被测程序的执行环境。不同的系统行为需要不同的观察和重放方法，并且最复杂的两种行为是动态的配置文件生成和网络交互。前者要求在观察过程中进行进程感知，在重放过程中进行文件系统同步。后者需要状态感知观察和重放。**

​		我们在70个基于Linux的物联网设备中的真实应用程序上评估了EQUAFL的兼容性和效率。结果表明，在执行速度方面，EQUAFL优于具有全系统仿真的AFL-QEMU（平均速度快26倍）和Firm-AFL（平均速度快14倍）。在实验中，EQUAFL在18个嵌入式设备中发现了10个以前未知的漏洞（包括6个CVE），证明了其在真实世界漏洞挖掘中的有用性。

**贡献**    因此，本文的贡献如下：

- 我们提出了一种称为EQUAFL的新技术，它可以自动设置执行环境，以在用户模式下完全模拟嵌入式程序。EQUAFL的增强型用户模式仿真可以保证高兼容性和高效率。
- 我们将EQUAFL实现为基于AFL和QEMU的覆盖率引导型灰盒模糊测试框架。
- 我们在主流嵌入式设备厂商不同产品系列中的70个真实的网络应用程序上广泛评估了EQUAFL。结果表明EQUAFL具有很高的效率和兼容性。同时，我们利用EQUAFL发现了10个0day漏洞，包括6个CVE。
- 我们发布了EQUAFL的源代码https://github.com/zyw-200/EQUAFL，以促进未来的研究。

## 2、背景

### 2.1 基于仿真的模糊测试

​		QEMU是用于各种CPU架构的通用机器仿真器。它支持两种仿真模式：全系统仿真和用户模式仿真。对于物联网系统来说，全系统仿真模拟嵌入式固件的整个系统，包括内核，驱动和应用程序。相反，用户模式仿真通过将系统调用委派给主机，仅模拟固件中单个基于Linux的应用程序。因此，与全系统仿真相比，用户模式仿真的优势在于更高的执行效率，因为仿真整个系统的开销可能非常高；然而用户模式仿真的缺点是缺乏兼容性，因为如果应用程序需要一些主机不支持的资源或系统调用，那么用户模式仿真将失败。

​		模糊测试是最有效的软件漏洞挖掘技术之一。AFL是一种广泛使用的基于覆盖率引导的灰盒模糊器，它支持使用QEMU作为被测软件执行的仿真引擎。

#### AFL+QEMU  用户模式仿真

​		默认情况下，AFL使用用户模式QEMU作为其仿真器。由于在用户模式仿真中，系统调用的执行直接转发到主机，如果主机与被测软件不兼容，被测软件的执行可能会导致意外状态，如崩溃、挂起等。例如，当我们在AFL中执行一个D-Link固件（`TRENDNet TEW-634GRU series`）中的应用程序（`sbin/httpd`），它将报告信息`“/var/run/httpd.pid: No such file or directory”`，然后快速退出，而不会运行到深层程序状态。尽管模糊测试的过程仍在继续，但它只测试应用程序的有限代码路径。为了探究失败的原因，我们使用用户模式QEMU测试了评估数据集中的70个网络应用程序，最后总结了失败的原因如下。

- **错误的启动变量。**一些被测程序在执行开始时终止，因为提供了错误的或甚至没有启动变量。
- **缺少动态生成的文件。**一些被测程序在执行之前可能需要一些文件，例如配置文件。在物联网设备中，大多数此类文件是在设备启动期间动态生成的。缺少这些文件将导致被测程序提前终止。
- **NVRAM配置不一致。**NVRAM（NON-Volatile Random Access Memory，即非易失性随机访问存储器）是一种闪存，广泛应用于物联网设备中来存储配置。如果存储在物联网设备NVRAM中的配置和存储在主机NVRAM中的配置彼此冲突，被测程序将出现执行错误。
- **不一致的网络行为。**物联网设备的大多数被测软件需要通过网络与用户交互。在主机无法提供正确的网络交互的情况下，被测程序将挂起或提前终止。
- **进程资源限制不一致。**Linux系统使用进程资源限制来防止进程过度消耗特定的系统资源。在某些情况下，主机上进程资源限制的值会远远高于仿真固件上的值，这可能会导致被测软件无法在主机上有效执行。
- **缺少硬件。**在某些情况下，被测软件需要特定的硬件来执行，缺少所需的硬件将导致执行失败。

​		因此，使用AFL+QEMU的用户模式仿真对物联网程序进行模糊测试会存在严重的兼容性问题，除了缺少硬件之外，所有执行失败的原因都可以通过使用全系统仿真来避免。

#### AFL+QEMU  全系统仿真

​		AFL与QEMU的全系统仿真相结合，可以支持整个固件映像和其应用程序的模糊测试。然而，由于QEMU添加了一个虚拟化层来支持整个固件仿真，因此全系统仿真的模糊测试速度可能非常慢。因此，用AFL+QEMU的全系统仿真对物联网应用进行模糊测试在实践中是不可行的。

#### AFL+QEMU  混合仿真

​		为了解决上述两种方法带来的挑战，Firm-AFL尝试将全系统仿真和用户模式仿真结合起来，以支持基于Linux的物联网应用程序的模糊测试。它在用户模式仿真下执行用户空间代码，并将系统调用重定向到全系统仿真，这在一定程度上保证了模糊测试过程的兼容性和效率。

​		然而，当应用程序有频繁的系统调用操作（如文件读取和写入）时，Firm-AFL仍然存在效率问题。如果在固件初始化期间生成了大量应用程序所需的文件，并且在原始文件系统中找不到这些文件，则Firm-AFL会频繁地将系统调用执行从用户模式仿真重定向到全系统仿真，这会大大降低执行速度。因此，Firm-AFL的效率仍有改进的空间。

### 2.2 术语

#### 客户机/主机

​		在全系统仿真中，客户机是指包含运行在模拟器上的初始化固件系统的虚拟机。主机是指托管在物理机上的操作系统（这里我们忽略主机也是虚拟机的情况）。客户机的模拟器运行在主机上。

#### 页全局目录

​		页全局目录指的是（PGD）进程顶部的物理页帧，这在现代操作系统中被广泛采用。PGD的起始地址在众多进程中是唯一的，因此我们可以用它来识别基于Linux的系统中的用户空间进程。在4.2中，我们利用PGD以进程感知来实现与文件相关的观察。

## 3、概述

​		我们系统的目标是实现对基于Linux的物联网设备中的网络应用程序进行有效的灰盒模糊测试。正如2.1中所讨论的，当前模糊测试的相关工作受到性能或者兼容性问题的影响。一方面，AFL的用户模式仿真保证了很高的模糊测试速度，但会导致低兼容性。另一方面，AFL的全系统仿真可以成功模拟更多的目标应用程序，但缺乏效率。为此，我们建议以一种创新的方式结合全系统仿真和用户模式仿真，以开发满足两个要求的模糊器：

- 高兼容性：应用程序的行为应与全系统仿真中的行为相同。
- 高效性：模糊测试的速度应该尽可能快。

​		我们提出的模糊器被称为EQUAFL，它是一个通过增强QEMU用户模式仿真的基于AFL的模糊测试框架。图1显示了EQUAFL的工作流程，包括两个主要步骤：观察和重放。在观察阶段，EQUAFL通过全系统仿真执行被测程序，并观察系统的关键行为。根据2.1中讨论的故障原因，系统的关键行为包括设置启动变量、文件生成、NVRAM相关操作、网络交互和进程资源限制。在这些行为中，最复杂的两个是动态配置文件生成和网络交互。因此，我们建议使用进程感知来观察动态配置文件生成和NVRAM配置（4.2 和 4.3）。同时，我们建议用状态感知来观察网络行为（4.4）。此外，我们使用几种启发式方法来观察其他信息，如启动变量和进程资源限制（4.1和4.5）。在重放阶段，EQUAFL通过在主机上部署系统资源（如动态配置文件）或在用户模式仿真期间拦截系统调用执行来进行重放。在对仿真系统中的关键行为进行观察和重放之后，被测程序可以在增强的用户模式仿真中完全执行，避免了将系统调用执行委托给全系统仿真所产生的开销。最后，我们通过调整被测程序的生命周期管理和模糊测试入口点，将增强的用户模式仿真与AFL模糊器集成，以便EQUAFL可以模糊从网络接收输入的IoT应用程序。

[![zJDREt.png](https://s1.ax1x.com/2022/11/24/zJDREt.png)](https://imgse.com/i/zJDREt)

## 4、方法

### 4.1 启动变量确定

​		启动变量指的是被测程序在仿真系统中启动时的参数和环境变量。如果没有正确的启动变量，被测程序可能会提前终止，因此当我们在用户模式仿真中执行被测程序时，需要配置好启动变量。这里我们将被测程序表示为*p*<sup>\*</sup>（**在本节的后续部分中，我们使用星号符号表示用于重播的变量**），将其程序名、参数和环境变量分别表示为*p*<sup>\*</sup><sub>name</sub>、*p*<sup>\*</sup><sub>vars</sub>、*p*<sup>\*</sup><sub>envs</sub>。通常，这些变量以各种方式存储在嵌入式固件中，包括被写进配置文件、被硬编码为二进制可执行文件、甚至被父进程传递。因此，很难通过静态方法实际提取这些参数。相反，我们建议通过对Linux内核进行静态模式分析和在全系统仿真期间进行运行时分析来获得*p*<sup>\*</sup><sub>vars</sub>和*p*<sup>\*</sup><sub>envs</sub>的具体值。

#### 观察

​		基于Linux内核在启动一个新程序时会调用`execve`系统调用的事实，我们通过在全系统仿真期间对内核函数`do_exeve`进行插桩来转储新启动程序的*p*<sub>name</sub>、*p*<sub>vars</sub>和*p*<sub>envs</sub>。由于`do_execve`是Linux内核的一个常见体系结构部分，因此可以安全地假设大多数基于Linux的固件不会修改该代码。因此，通过分析Linux内核的源代码，我们总结了一种二进制模式，该模式可用于在模拟固件时查找用于转储这些启动变量的确切汇编指令。具体来说，我们找到了三个函数调用指令（一个调用`copy_strings_kernel`，另两个调用`copy_strings`），其中包含可用于计算*p*<sub>name</sub>、*p*<sub>vars</sub>和*p*<sub>envs</sub>地址的寄存器。然后，我们从这些指令中找到一个最近的后继基本块，QEMU可以在这里插桩。最后，我们在系统仿真期间转储该基本块的值。具体来说，我们选择的基本块正好是函数`search_binary_handler`的入口点。

#### 重放

​		在观察之后，我们获得了一个*p*<sub>name</sub>、*p*<sub>vars</sub>和*p*<sub>envs</sub>的集合，它可以用来表示固件仿真期间的不同进程。然后，我们将*p*<sub>vars</sub>和*p*<sub>envs</sub>识别为目标*p*<sup>\*</sup><sub>vars</sub>和*p*<sup>\*</sup><sub>envs</sub>，其中*p*<sub>name</sub>等于*p*<sup>\*</sup><sub>name</sub>。在模糊测试过程中，我们使用用户模式仿真，利用*p*<sup>\*</sup><sub>vars</sub>和*p*<sup>\*</sup><sub>envs</sub>来执行*p*<sup>\*</sup>。最终，被测程序可以在用户模式仿真下运行到深层状态，以便进一步测试。

### 4.2 文件系统状态同步

​		在全系统仿真中，许多固件映像安装了一个临时文件系统，并在初始化阶段不断更改文件系统状态。在主机上，如果不初始化固件，就无法更新文件系统状态。因此，由于主机的文件系统状态不正确，被测程序将在用户模式仿真下执行到非预期状态。例如，固件在初始化阶段会动态地生成配置文件等文件。但这些文件在固件的原始文件系统中找不到。因此，被测程序可能会因为没有访问到主机上的特定配置文件而执行到错误状态。

​		为此，我们使用观察—重放策略来同步客户机和主机之间的文件系统状态。具体来说，我们试图观察客户机中与文件相关的系统调用的执行。对于每个观察到的与文件相关的系统调用的执行，我们都在主机上重新执行它。我们不断重复这种观察—重放操作，直到我们检测到被测程序开始运行。直到这时，满足被测程可执行的文件系统状态已完全设置。不幸的是，在主机上执行重放操作时，一些与文件相关的系统调用参数是未知的。例如，如图2右侧所示，当我们重新执行`write`系统调用时，我们不能直接指定*fd<sup>\*</sup><sub>host</sub>*的值。为了解决这个问题，我们提出了一种进程感知的观察方法来构建客户机和主机之间的文件映射。

#### 准确的进程识别

​		为了实现进程感知观察，我们提出首先去识别客户机中当前正在执行的进程。进程识别的工作流程包括两个步骤：进程收集和进程推理。在进程收集步骤中，我们在固件仿真期间不断更新所有正在运行的进程信息。具体来说，由于`fork`和`execve`系统调用都参与了创建新进程的过程，因此我们在这两个系统调用执行结束时插桩，以收集新产生进程的信息。在插桩点，我们遍历`task_struct`数据结构（Linux内核中的进程描述符），并找到新生成的表示新进程的数据结构。对于每个进程，我们从`task_struct`获取信息，包括页全局目录（PGD）的起始地址、进程标识符（PID）和父进程的PID（PPID）。最后，如等式1所示，集合*Collection*包含了所有正在运行的进程的信息。在进程推断步骤中，我们通过监视特定的寄存器或内存区域来获取当前正在执行的进程*p*的PGD值。例如，对于ARM架构，我们通过访问系统控制协处理器（CP15）的指定寄存器来获得进程*p*的PGD值。在获得PGD的值后，我们进一步搜索`Collection`以找到与PGD值相等的匹配项。我们获得了进程*p*的PID和PPID，这将用于客户机和主机之间的文件系统状态同步。
$$
Collection \gets \{(t_{pgd},t_{pid},t_{ppid})~|~t \in task\_struct\} \tag{1}
$$

[![ztTofU.png](https://s1.ax1x.com/2022/11/26/ztTofU.png)](https://imgse.com/i/ztTofU)

#### 进程感知观察

​		有了在客户机中识别当前正在执行的进程的能力，我们开始用进程感知去观察与文件相关的系统调用执行。最初，我们过滤掉不会影响文件状态或修改文件内容的文件相关系统调用（例如，读取）。然后，我们将其余与文件相关的系统调用根据其参数分为两种类型，如表1所示：一种类型是直接处理文件路径；另一种类型是处理文件描述符。对于后一种类型，我们无法在主机上轻松获取相应的文件描述符。因此，我们提出观察文件与进程感知的关系，如图2所示。首先，我们监视创建文件的系统调用（例如，打开一个文件），并获取返回的文件描述符*fd<sub>guest</sub>*。此外，我们还识别执行这个系统调用的当前正在运行的进程*p*。同时，我们在主机上重新执行相同的系统调用，并获取返回的文件描述符*fd<sub>host</sub>*。由于固件可以通过执行类似`dup`（其主要工作就是用来复制一个打开的文件号，使两个文件号都指向同一个文件）的系统调用来创建文件描述符的一个拷贝，因此我们将相关的客户机文件描述符添加到集合*FD<sub>guest</sub>*中，如等式2所示。由于Linux是多任务操作系统，所以子进程可以通过继承文件描述符以参与文件的修改。因此，我们将这些进程关联起来，并将它们添加到*P*中，如等式3所示。在那之后，我们创建了如等式4所示的映射*M*，这建立起了*P*、*FD<sub>guest</sub>*和*fd<sub>host</sub>*之间的关系。这意味着，在随后的执行中，如果进程属于*P*，并且它在属于*FD<sub>guest</sub>*的文件描述符上执行其他与文件相关的系统调用，我们将在主机上对*fd<sub>host</sub>*重新执行这个系统调用。
$$
\Delta FD_{guest} \gets \{\forall fd^{'}~|~fd^{'}=DUP(fd)\wedge fd\in FD_{guest}\} \tag{2}\\\
FD_{guest} \gets FD_{guest} \cup \Delta FD_{guest}
$$

$$
P \gets \{\forall p^{'}~|~p^{'}_{pid}=p_{pid} \vee p^{'}_{ppid}=p_{pid}\} \tag{3}
$$

$$
M:P \times FD_{guest} \longmapsto fd_{host} \tag{4}
$$

|  Argument Type  |                      System Calls                       |
| :-------------: | :-----------------------------------------------------: |
|   File paths    |   mount, mkdir, rmdir, mkdirat, link, symlink, unlink   |
| File descriptor | open, read, write, dup, dup2, dup3, create, fcntl, pipe |

[![zNk4M9.png](https://s1.ax1x.com/2022/11/26/zNk4M9.png)](https://imgse.com/i/zNk4M9)

#### 重放

​		对于每个在客户机上调用的与文件相关的系统调用，我们在主机上重新执行它以同步文件系统状态。总的来说，我们在算法1中展示了文件系统调用重放的总体过程。算法的输入包括（1）*id<sub>sys</sub>*：我们正在重放的系统调用；（2） *p<sup>\*</sup>*：在客户机中执行系统调用*id<sub>sys</sub>*的进程；（3）*obj_arg*：引用文件对象的*id<sub>sys</sub>*参数。它可以是一个文件路径或文件描述符。（4）*other_args*：除*obj_arg*以外的*id<sub>sys</sub>*的参数；（5）*RDIR*：被提取的固件文件系统在主机上的绝对目录路径。

​		与文件相关的系统调用执行的重放过程可以分为两部分。对于处理文件路径*path<sub>guest</sub>*的系统调用，我们推断一个新的文件路径*path<sub>host</sub>*，以确保重放可以限制在提取的固件目录中，而不是在主机上的根目录中。如果*path<sub>guest</sub>*是一个绝对路径，那么我们在*path<sub>guest</sub>*前添加*RDIR*以生成*path<sub>host</sub>*。如果*path<sub>guest</sub>*是一个符号链接，而且它的源*path<sub>source</sub>*是一个绝对路径，那么我们在*path<sub>source</sub>*前面添加*RDIR*。之后，我们在*path<sub>host</sub>*上执行系统调用（第2行—第12行）。另一方面，对于处理文件描述符的文件相关系统调用，我们识别当前正在执行的进程*p<sup>\*</sup>*，并且利用通过等式4而构建的映射M。基于此，我们找到了*fd<sup>\*</sup><sub>host</sub>*，并最终在主机上对其执行系统调用（第14到16行）。

### 4.3 NVRAM配置

​		我们使用观察—重放策略在主机中生成运行时的NVRAM配置。

#### 观察

​		在最先进的全系统仿真技术（例如FIRMADYNE）中，分配常规文件来存储NVRAM配置的数据。因此，NVRAM访问的仿真是通过将相关API重定向到此类常规文件中的数据访问来实现的。由于我们已经在主机上实现了文件系统状态同步，如4.2所述，所以存储NVRAM配置数据的文件也会在主机上生成。

#### 重放

​		在用户模式仿真中，我们通过将被测程序的NVRAM访问重定向到主机上的NVRAM配置文件来进行重放。具体来说，在`LD_PRELOAD`技术的帮助下，我们使用一个自定义库执行被测程序，该库覆盖了所有与NVRAM相关的API，包括设置、获取、提交和清除NVRAM操作。

```python
在UNIX的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。
```

### 4.4 网络行为

​		与其他的系统行为不同，网络行为可能会受到与外界网络交互的影响。例如，用户在不同的场合下向被测程序发送请求，与网络相关的系统调用序列也会在不同的运行中有很大的差别。为了模拟网络行为，我们首先从大量观察到的网络相关系统调用序列中学习网络状态机。然后，我们基于状态机模拟被测程序的网络行为。

#### 状态感知观察

​		首先，我们在全系统仿真期间收集被测程序的网络相关系统调用序列。由于Linux系统中的应用程序不仅使用套接字进行网络通信，而且使用套接字进行进程间通信，因此我们通过监视套接字系统调用的类型参数来识别与网络相关的套接字。如果类型与`AF_INET6`或`AF_INET`相同，我们将生成的套接字标识为一个与网络相关的描述符*fd<sub>net</sub>*。稍后，在*fd<sub>net</sub>*上执行的系统调用将被标识为与网络相关的系统调用。在我们收集与网络相关的系统调用序列之后，我们执行图3所示的状态机，以指导网络行为的仿真。具体来说，Linux内核提供一系列常见的网络相关系统调用，以支持网络通信。大多数与网络相关的系统调用，包括`bind、listen、accept、read/recv/recvfrom`，都是按照一定的顺序执行的。否则，网络相关应用程序无法实现正确地网络通信。

**（Poll系统调用的用途是：在一段指定时间内，轮询一定数量的文件描述符，以测试其中是否有就绪者。）**

**（Select 系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符的可读、可写和异常等事件。）**

​		此外，在我们的网络应用程序中经常使用I/O复用操作来监视网络套接字是否准备好读或写。代表性的系统调用包括`Poll、Select`。与典型的套接字操作不同，它们被认为不是实现网络通信所必需的。从我们的观察中，我们发现I/O复用的使用在不同的应用中表现出多种形式。幸运的是，网络状态转换过程也可以建模，如图3所示：（1）当应用程序第一次在*fd<sub>net</sub>*上执行轮询（Poll）时，*fd<sub>net</sub>*已经准备好连接，并且*fd<sub>net</sub>*设置为就绪状态。在那之后，新的网络描述符*fd<sup>'</sup><sub>net</sub>*被接受。（2）当应用程序在*fd<sup>'</sup><sub>net</sub>*上执行轮询时，*fd<sup>'</sup><sub>net</sub>*设置为就绪状态。在那之后，*fd<sup>'</sup><sub>net</sub>*等待数据的到来。（3）当应用程序在第三次执行轮询时，*fd<sup>'</sup><sub>net</sub>*已经接收到数据，当前的模糊测试迭代可以终止，然后在大多数情况下会运行到下一个模糊测试循环。

#### 重放

​		在重放阶段，我们遵循图3中的状态机来模拟与网络相关的系统调用。具体来说，我们在与网络相关的系统调用开始处插桩，然后在成功执行时提供预期结果。我们还通过填充相应的内存来维护网络资源（如`sock_addr`数据结构），从而确保依赖于这些网络相关资源的后续执行能够正确执行下去。

[![zNUqFf.png](https://s1.ax1x.com/2022/11/26/zNUqFf.png)](https://imgse.com/i/zNUqFf)

### 4.5 进程资源限制

​		进程资源限制是指应用程序可以使用的特定内核资源的最大数量，资源限制的设置不当可能会影响被测程序的行为。例如，资源限制`RLIMIT_NOFILE`指定了被测程序可以打开的文件描述符的最大数量。在一些被测程序的执行初期，它们可以遍历所有的系统描述符，其数量范围从0到`RLIMIT_NOFILE`的限制。因此，设置较大的`RLIMIT_NOFILE`限制值将减慢被测程序的执行速度。事实上，由于系统性能不同，主机内核中的`RLIMIT_NOFILE`值远高于嵌入式固件。因此，我们不能直接使用主机上的资源限制值。

​		因此，我们使用观察—重放策略来设置用户模式仿真中被测程序的进程资源限制。需要注意的是，Linux内核提供了`setrlimit`和`getrlimit`系统调用来设置或获取进程资源限制的值。因此，我们预先通过在固件的全系统仿真期间检测`getrlimit`来检索进程资源限制值。之后，当被测程序第一次通过`getrlimit`要求获取资源限制时，我们将观察到的值直接提供给它们。

## 5、实现

### 5.1 仿真

#### 观察

​		最初，EQUAFL利用FIRMADYNE进行全系统仿真来执行被测程序，这是一个对基于Linux的嵌入式固件进行全系统仿真的自动化和可扩展的平台。在全系统仿真期间，EQUAFL通过在系统调用执行结束时对QEMU的全系统模式进行插桩记录来进行观察。具体而言，当固件执行一个系统调用时。QEMU将处理由系统引起的特定异常或中断。EQUAFL将其视为系统调用执行的起点，并记录当前执行上下文。随后，固件将执行到内核空间，EQUAFL在每个基本块的末尾进行插桩来检测固件执行是否返回到用户空间。当固件执行到用户空间并且执行上下文等于之前的记录时，EQUAFL将其视为系统执行的结束。最后，我们可以在全系统仿真中收集每个系统调用执行的参数和返回值。

#### 重放

​		EQUAFL从两个方面进行重放。对于启动变量、文件系统状态同步、NVRAM配置，EQUAFL通过直接在主机上部署相关资源来实现重放机制，被测程序在用户模式仿真中进行模糊性测试可直接使用该机制。对于网络行为、进程资源限制，EQUAFL通过对QEMU的用户模式进行插桩记录来实现重放策略。在启动变量确定阶段，我们使用IDA Pro找到转储启动变量的确切点。此外，在文件系统状态同步阶段，我们首先使用Binwalk来解压固件并获得原始文件系统。在文件系统状态同步之后，我们使用`chroot`将提取的固件文件系统的顶级目录指定为根目录，以便用户模式仿真中的PUT可以正确访问具有绝对路径的文件。

### 5.2 模糊测试

​		此外，我们通过修改以下策略将增强的用户模式仿真与AFL集成。

#### 被测程序生命周期管理

​		通常，AFL使用被测程序的主函数作为模糊测试的入口点。它会在入口点fork一个子进程，并在派生的进程中进行模糊测试。当被测程序执行到结束时，AFL退出派生的进程，并循环回到下一个模糊迭代的入口点。在我们的系统中，我们进一步缩短了模糊测试循环的生命周期，以提高效率。具体来说，我们将接收网络输入的系统调用指定为入口点。同时，当我们检测到被测程序执行到`Poll`或`Select`这种表示准备接受新的网络请求的系统调用时，我们就退出当前的模糊测试迭代，如图3所示。

#### 模糊测试的入口点

​		通常，AFL将测试输入作为文件提供给被测程序。与AFL不同，EQUAFL将输入送到存储网络输入的存储器缓冲器（memory buffer）。具体来说，我们通过插桩检测接收网络输入（如`read、recv和recvfrom`）的系统调用来实现输入的传送。在传送模糊输入之后，我们利用模糊输入的长度对返回值进行赋值。

## 6、评估

​		我们通过对QEMU全系统模式和用户模式的代码进行修改，实现了EQUAFL的原型。此外，我们还修改了AFL以更改afl-fuzz可接受的参数，以便目标应用程序的参数和环境变量可以被正确加载。

​		有了这个原型，我们从以下方面评估EQUAFL的性能。

#### 兼容性

​		我们首先评估EQUAFL，以检查它是否能够成功模糊AFL无法直接模糊的应用程序。此外，我们将EQUAFL中目标应用程序的系统调用序列/轨迹与基于全系统仿真的模糊测试进行比较，以检查增强的用户模式仿真的正确性（6.2）。

#### 效率

​		首先，我们通过将其与纯用户模式仿真进行比较来测量系统中引入的开销。然后，我们通过与AFL全系统仿真和Firm-AFL的吞吐量进行比较来评估EQUAFL的效率（6.3）。

#### 漏洞发现能力

​		我们评估EQUAFL能否成功发现真实世界嵌入式固件中的漏洞。

### 6.1 实验设置

#### 基准

​		我们在实验中使用两个不同的数据集作为基准：①第一个数据集包含两组**标准**基准：`nbench`和`lmbench`。②另一个数据集由来自三个主要嵌入式设备供应商（包括`D-Link、TRENDnet和NETGEAR`）的70个嵌入式固件映像组成。最初，我们通过爬取相关供应商的网站来收集固件映像。然后，我们在AFL-Full和Firm-AFL上运行它们，并获得了可以成功仿真和测试的固件样本。最终，我们获得了不同产品系列中的70个固件样本作为第二个数据集的候选。固件映像的汇总信息列于表2中。

|     Vendor     |               Product series               |                     Device types                      | Samples  |
| :------------: | :----------------------------------------: | :---------------------------------------------------: | :------: |
|  <br />D-Link  |  DIR / DI<br />DAP / DSL<br />DSP / GO-RT  |      Router<br />Range extender<br />Smart plug       | <br />30 |
| <br />TRENDnet |   TEW-DRU / TV-IP<br />TEW-AP / TEW-DRE    | Camera / Router<br />Access point<br />Range extender | <br />11 |
| <br />NETGEAR  | WNDR / JNR<br />XWN / WNCE<br />EX / XA VN |  Router / Access point<br />Wi-Fi adapter / Extender  | <br />29 |

​		标准数据集中的程序较小且没有任何bug。因此，我们使用它们来评估EQUAFL的兼容性和效率。我们从真实世界的固件中收集的应用程序包含bug，因此我们使用它们不仅评估兼容性和效率，还可以揭示EQUAFL的效率提升是如何帮助发现真实世界的漏洞的。

#### 基线

​		我们在实验中选择了三条基线。

- AFL-User：AFL-User遵循默认的AFL设置，其中用户模式QEMU被用作仿真器。
- AFL-Full：我们将AFL与QEMU的全系统仿真相结合，以支持全系统仿真中目标应用程序的模糊测试。在系统中，我们利用DECAF中的VMI模块来监控目标应用程序的进程。
- Firm-AFL：Firm-AFL是一款先进的灰盒模糊器，它同时利用全系统和用户模式仿真来支持基于Linux的物联网应用程序的有效模糊。

#### 配置

​		为了提高所有实验的模糊测试效率，我们在AFL中使用字典选项。通过对目标应用程序的静态分析收集用作字典token的关键字。对于每个目标应用程序，我们提供一个正常的网络请求作为初始种子。为了进行兼容性和效率评估，实验在12核Intel（R）Xeon（R）E5-1650 v3 3.50GHz CPU机器上进行，该机器具有Ubuntu 18.04.5 LTS操作系统和15.6GB RAM。对于漏洞发现能力评估，该机器是18核Intel（R）Xeon（R）CPU E5-2699 v3 2.30GHz CPU机器，带有Ubuntu 18.04.5 LTS LTS操作系统和188GB RAM。

​		为了减轻模糊器的随机性，每个实验重复5次。此外，我们还遵循[24]的建议进行了Mann-Whitney U测试，并计算了*A*12的值。

### 6.2 兼容性

​		表3显示了EQUAFL和AFL-User在真实世界数据集上的执行结果。真实的应用程序是根据Firmadyne的指示所选择的。AFL-Full和Firm-AFL都能够成功地模拟它们。我们将这些结果分为四种状态：（1）*CRA*—当模糊器尝试使用初始种子进行第一次fuzz时（dry run），应用程序发生崩溃；（2）*HAN*—当模糊器尝试使用初始种子进行第一次fuzz时，应用程序挂起；（3）*ERR*—应用程序的进程可由模糊器发起。然而，模糊器会报告一些错误，例如当它尝试使用初始种子进行第一次fuzz时找不到文件。（4）*SUCC*—模糊器可以在不报告任何错误的情况下启动应用程序的进程。

​		在70个应用程序中，总共有66个可以在EQUAFL中达到SUCC状态。相反，没有一个应用程序可以在AFL-User的默认用户模式仿真下正确执行。对于D-Link和TRENDnet固件映像，EQUAFL可以将大部分应用程序运行到SUCC状态，而AFL-User将大部分应用运行到ERR状态。对于NETGEAR固件映像，EQUAFL可以将所有应用程序运行到SUCC状态，而AFL_User将它们运行到其他不正确的状态。结果表明，EQUAFL在成功执行实际应用程序方面比AFL-User更有效。

​		此外，我们通过比较相同的种子在EQUAFL和AFL-Full中的执行轨迹来描述EQUAFL的仿真精确度。这里，我们重点关注执行轨迹上系统调用序列的正确性。请注意，我们这里仅在应用程序收到输入后收集系统调用序列，原因有两个：首先，全系统仿真中的网络应用程序通常会等待一段时间，直到收到网络输入。但EQUAFL中的网络仿真策略不同。EQUAFL仅在首次遇到网络套接字时处理网络请求。因此，两个系统在接收网络输入之前的系统调用序列明显不同。第二，模糊器主要关注在接收到输入之后监视应用程序的执行上。因此，我们只需要在应用程序处理输入后检查系统调用序列的正确性。

​		我们使用Levenshtein算法来计算系统调用序列的相似性。图5显示了序列相似性结果。在处于*SUCCESS*状态的66个应用程序中，44个应用程序在系统调用序列比较中相同。同时，有16个应用程序具有较高的相似度，其值大于89%。只有六个应用程序在系统调用序列比较中完全不同。通过进一步调查，我们发现这六个应用程序的差异主要是因为这些应用程序涉及进程间通信，这导致系统调用序列发生变化。总的来说，EQUAFL可以执行目标应用程序，几乎与真实世界数据集上的全系统仿真相同。

​		最后，我们还在标准数据集上评估EQUAFL，看看它是否能很好地工作。具体来说，我们使用了`nbench`来评估EQUAFL中增强的用户模式仿真的准确性。如果`nbech`生成的输出没有错误，则证明EQUAFL的仿真是正确的。我们的评估结果（见[49]）表明，增强的用户模式仿真可以正确执行所有程序。

​		总之，EQUAFL可以成功执行标准数据集中的所有程序，以及真实世界数据集中的大多数（70个程序中的66个）程序。此外，对于成功执行的程序，其系统调用序列与全系统仿真基本相同。总的来说，EQUAFL的兼容性与全系统仿真相当，并且比纯用户模式仿真要好得多。

### 6.3 效率

​		我们从两个方面评估EQUAFL的效率：①我们测量了EQUAFL的模糊吞吐量，并将其与AFL-Full和Firm-AFL进行了比较。②我们评估了EQUAFL中增强的用户模式仿真相对于纯用户模式仿真的开销。由于纯用户模式仿真无法正确执行实际应用程序，因此我们使用标准数据集来完成开销评估。

#### 真实数据集

​		我们首先通过将EQUAFL与AFL-Full和Firm-AFL进行比较来评估其吞吐量性能。由于EQUAFL的主要贡献是加速应用程序在模拟器上的执行，因此我们没有改变AFL的任何模糊策略。所以EQUAFL中的模糊器与Firm-AFL和AFL-Full中使用的模糊器相同。因此，在同一输入上执行目标应用程序可以反映EQUAFL的性能增益。因此，我们收集了来自honggfuzz项目的1188个种子，以评估EQUAFL的吞吐量。

​		对于在EQUAFL中运行的每个应用程序，我们首先轮流测试所有种子，并计算每个种子的平均执行时间。我们重复实验5次，得到平均值*ave_t*。然后，平均吞吐量*TH<sub>EQ</sub>*被推断为$1 \over ave\_t$。同样，我们获得了来自AFL-Full和Firm-AFL相应的值*TH<sub>Full</sub>*和*TH<sub>Firm</sub>*。图4显示了*TH<sub>EQ</sub>*、*TH<sub>Full</sub>*和*TH<sub>Firm</sub>*的结果，这些应用程序可以利用种子输入在基线上成功执行。最后，我们计算了每个应用程序的吞吐量性能优化率$Imp_{Full} = {TH_{EQ} \over TH_{Full}}$和$Imp_{Firm} = {TH_{EQ} \over TH_{Firm}}$。结果表明，*TH<sub>Full</sub>*的范围为5.1至78倍（平均26倍），*TH<sub>Firm</sub>*的范围为2.3至48倍（平均14倍），这表明EQUAFL在模糊化速度方面优于最先进的技术。

#### 标准数据集

​		我们使用`nbench`和`lmbench`来评估增强的用户模式仿真的开销。具体来说，`nbench`用于测试系统的CPU和内存能力。结果（见[49]）表明，EQUAFL的性能与纯用户模式仿真的性能相似，因为CPU的执行机制在增强的用户模式仿真中保持不变。然后我们使用一个名为`lmbench`的系统调用开销基准来评估。结果（参见[49]）表明，文件相关和网络相关系统调用的开销都很小。

​		总结，EQUAFL执行实际应用程序的速度平均比AFL-Full快26倍，比Firm-AFL快14倍。此外，与纯用户模式仿真相比，EQUAFL的开销在标准数据集上是微不足道的。这表明，与最先进的技术相比，EQUAFL具有显著更好的效率。

### 6.4 漏洞发现

​		我们将EQUAFL应用于真实世界的应用程序以挖掘它们的漏洞。如表5所示，EQUAFL总共可以发现十个漏洞，这些漏洞会影响十八个嵌入式设备系列。然后我们手动分析这些漏洞的根本原因，最后确认9个是NULL指针解引用漏洞（ 解引用，顾名思义，其实就是对一个指针进行访问其中的值，那么空指针解引用就代 表了这个指针是 NULL），1个是整数溢出漏洞。我们然后搜索了在线漏洞信息，之前只有一个漏洞被其他安全研究人员发现。据我们所知，其余九个漏洞仍不为公众所知。我们已经向制造商报告了这些情况，其中6个被认定为0day，并分配了CVE编号。

​		我们在有缺陷的现实世界应用程序上进行了24小时的实验，以比较EQUAFL、Firm-AFL和AFL-Full上的模糊结果。首先，我们为每个漏洞选择一个固件应用程序。对于具有多个漏洞的固件映像，我们仍然选择一个测试应用程序。然后，我们对每个进行模糊测试实验，并行重复5次，持续24小时。

​		图6显示了EQUAFL、Firm-AFL和AFL-Full在一段时间内发现的单独漏洞的平均数量。图6中的线是检测到的唯一漏洞的平均数量。结果表明，EQUAFL可以比Firm-AFL和AFL-Full更快地发现所有漏洞（除了EQUAFL和Firm-AFL并列的一个漏洞）。表4显示了每种技术暴露第一个漏洞的时间。$\mu$TTE测量了五次运行的平均时间。**Factor**测量了与基线相比$\mu$TTE的性能增益。$\hat{A}$12意味着，如果我们从五次重复中随机选择一次，EQUAFL的表现会比基线更好。我们可以看到，EQUAFL可以比AFL -ull和Firm-AFL更快地发现漏洞。

​		总结，EQUAFL可以比AFL-Full和Firm-AFL更快地检测漏洞。这表明EQUAFL的增强用户模式仿真确实有助于提高灰盒模糊器的漏洞检测能力。

## 7、有效性威胁

​	有效性威胁来自三个方面。首先，EQUAFL可以支持嵌入式应用中NVRAM外围操作的仿真。不幸的是，某些应用程序在执行期间可能会访问其他定制的硬件外围设备，这是不受支持的。我们将在未来提供更多定制外设的仿真。其次，EQUAFL采用启发式策略来绕过与其他应用程序的进程间通信。然而，在某些情况下，这些粗粒度启发式可能会失败，因为这些情况下，后续操作会受到通信内容的影响。第三，EQUAFL可以从嵌入式固件中发现单个应用程序中的漏洞。无法发现跨多个应用程序的漏洞[9，39]。

## 8、相关工作、

​		我们从以下角度总结了嵌入式系统的自动漏洞挖掘技术。

#### 静态分析

​		已经提出了几种技术[14，15，46]来对固件映像进行大规模同源性分析，以发现类似的漏洞。然而，这些技术需要利用已知漏洞的代码特征，这在发现未知漏洞方面是有限的。PIE[13]利用机器学习算法来识别嵌入式固件中的脆弱函数。Firmalice[40]结合了静态分析和符号执行技术来发现固件中的认证绕过漏洞。DTaint[12]执行细粒度数据流和结构分析，以查找固件中的污点式漏洞。Karonte[39]和SaTC[9]通过利用嵌入式固件中前端和后端程序的交互信息，可以有效地发现嵌入式固件中的漏洞。然而，这些静态技术只能产生警报，漏洞需要进一步的手动验证。

#### 动态分析

​		大多数动态分析技术与EQUAFL正交。Avatar[47]为嵌入式设备提供了一个混合仿真框架，它将软件仿真器和真实设备结合在一起。Firmadyne[5]和FirmAE[23]为基于Linux的嵌入式固件映像开发了全软件仿真器。在我们的工作中，我们利用Firmadyne来支持基于Linux的嵌入式固件的全系统仿真。

#### 模糊测试

​		大多数现有的模糊技术侧重于提高效率而非适用性[3，4，6，7，10，11，16，26-29，43-45]，这意味着理论上它们的方法与EQUAFL正交，并且可以由EQUAFL集成。为了提高适用性，[1，22，48]提出了几种创建用于测试库目标的可用模糊驱动程序的方法。对于模糊嵌入式系统内的软件，IOTFUZZER[8]通过直接向设备生成有效的协议输入来执行模糊化。Muench等人[32]通过将boofuzz[36]与各种仿真器方法集成，提出了嵌入式设备的模糊化框架。然而，它们是黑盒模糊方法。Firm-AFL[51]结合了全系统和用户模式仿真，以在基于Linux的物联网固件应用程序上执行应用程序的模糊化。然而，如果应用程序有大量的系统调用需要转发到整个系统仿真，则执行将频繁地在两种仿真模式之间切换，这最终导致效率低下。Firmcorn[19]使用CPU仿真器执行固件中的易受攻击代码，从而实现了面向漏洞的模糊化的高效性。然而，寄存器和上下文存储器信息仍然不足以准确执行固件代码。其他技术，如Firm-Fuzz[41]和EM-Fuzz[17]，仍然采用嵌入式固件的全系统仿真，这存在效率问题。

## 9、总结

​		我们为基于Linux的嵌入式固件中的网络应用程序提出了一种有效的模糊化框架EQUAFL。该框架允许通过增强的用户模式仿真模糊物联网应用程序，从而避免QEMU的全系统仿真成本。我们根据标准基准和来自三大嵌入式设备供应商（包括D-Link、TRENDnet和NETGEAR）的70个实际应用程序评估EQUAFL。结果表明，EQUAFL在模糊兼容性方面优于AFL，在模糊效率方面优于AFL-Full和Firm-AFL。EQUAFL已经在这些固件映像中发现了十个漏洞，包括六个CVE。未来，我们将尝试支持更多定制的硬件外设，以进一步提高EQUAFL的兼容性。

## 数据可用性声明

​		我们已经将工件上传到Zenodo[50]，其中包括源代码和README.md，以指导用户运行docker容器并执行测试。