# SRFuzzer：An Automatic Fuzzing Framework for Physical SOHO Router Devices to Discover Multi-Type Vulnerabilities

# SRFuzzer：一种用于发现物理SOHO路由器设备多类型漏洞的自动模糊化框架

## 摘要

​		SOHO（小型办公室/家庭办公室）路由器为终端设备提供连接到互联网的服务，在网络空间中发挥着重要作用。不幸的是，这些路由器普遍存在安全漏洞，特别是在Web服务器模块中，严重危害了终端用户的安全。为了发现这些漏洞，对SOHO路由器的Web服务器模块进行模糊测试是最流行的解决方案。然而，由于缺乏输入规范、缺乏路由器内部运行状态、缺乏测试环境恢复机制等原因，其有效性受到限制。此外，通常情况下，模糊测试只报告内存损坏漏洞，并无法发现其他漏洞，例如基于Web的漏洞。

​		本文提出了一个名为SRFuzzer的解决方案，以解决这些问题。它是一个完全自动化的模糊测试框架，用于测试物理SOHO设备。它通过利用两个输入语义模型（即KEY-VALUE数据模型和CONF-READ通信模型）不断有效地生成测试用例，并利用电源管理自动恢复测试环境。它还协调多样化的变异规则和多个监控机制以触发多类型漏洞。据我们所知，这是第一个全过程自动化的SOHO路由器模糊测试框架。我们在五家供应商的10个热门路由器上运行了SRFuzzer。总共发现了208个独特的异常行为，其中97个已经确认为0-day漏洞。实验结果表明，SRFuzzer在发现漏洞类型和数量方面优于现有的最先进解决方案。

## 1 引言

​		越来越多的终端设备，例如笔记本电脑、平板电脑、智能手机、智能家居设备和可穿戴设备，被用于社交生活中。它们通常通过小型办公室和家庭办公室（SOHO）路由器连接到互联网。。因此，SOHO路由器处于一个突出的位置，可以隔离终端用户与外部互联网[15]，并处理终端用户的所有流量。SOHO路由器的安全性比以往任何时候都更加重要。

​		不幸的是，SOHO路由器普遍存在安全漏洞[4]，[29]。根据最近的一份报告[6]，83%的热门路由器包含有漏洞的代码。这些漏洞是攻击者的主要攻击目标之一。再2018年，Cisco Talos发现了针对Linksys、MikroTik、NETGEAR和TP-Link网络设备的恶意软件VPNFilter，这些设备都是SOHO路由器，并感染了至少54个国家/地区的至少50万台设备。此外，领先的漏洞获取平台Zerodium [3]在2018年增加了对路由器的要求。因此，发现SOHO路由器中的漏洞变得非常重要。

​		SOHO路由器的典型架构如图1右侧所示。作为网络设备，SOHO路由器为连接到它的终端设备提供网络服务，例如路由。更重要的是，由于缺乏用户接口，例如键盘、视频、鼠标，它还利用Web服务进行管理和配置。这些Web服务由一些广泛使用的协议提供，例如超文本传输协议（HTTP）。在本文中，我们将这些协议称为管理协议。

[![pCKG2FJ.png](https://s1.ax1x.com/2023/06/15/pCKG2FJ.png)](https://imgse.com/i/pCKG2FJ)

​		典型的管理协议是通过在原始设备中嵌入Web服务器（后端）来实现的。通常，不同路由器中的Web服务器是由设备供应商定制的，并且更容易受到攻击。最近的研究[12]，[15]，[11]显示，大多数SOHO路由器漏洞都与Web服务相关，例如PHP服务器端脚本中的命令注入漏洞和处理移动应用程序Web请求时的内存损坏漏洞。因此，本文还侧重于发现SOHO路由器的Web服务器的漏洞。

​		模糊测试（即Fuzzing）被认为是一种发现漏洞的强大技术。然而，除了IoTFuzzer[11]这种基于应用程序的模糊测试框架外，关于模糊测试SOHO路由器Web服务器（FWSR）的研究很少。该方法借助能够控制设备的移动APP的程序逻辑，生成有意义的测试用例并触发设备bug。虽然它在一定程度上解决了FWSR的问题，但总体而言，FWSR仍然具有挑战性。

**挑战1：模糊专用系统**

​		作为嵌入式设备，SOHO路由器的功能是专用的，不容易扩展。因此，在模糊测试期间无法直接获取其内部运行状态，并且当设备在测试期间被卡住时，很难恢复其正常运行状态。这使得FWSR难以持续而有效地运行。虽然基于仿真的模糊测试是获取内部执行信息以指导模糊测试的一种有前途的方法，但在全系统模式下模拟各种路由器方面存在限制。（见第6节）

**挑战二：分析输入语义**

​		Web服务器的输入符合标准协议，例如超文本传输协议（HTTP），但是它们的内部数据编码交换信息的格式在不同的路由器之间是各不相同的。如果没有调查内部数据和信息交换过程的格式，FWSR在代码覆盖方面就不会有效。

**挑战3：发现多种类型的漏洞**

​		如前所述，Web服务器几乎是由厂商从前端到后端进行定制的。因此，FWSR不仅需要发现Web漏洞，如命令注入和跨站脚本攻击，还需要发现内存损坏等漏洞。不幸的是，不同类型的漏洞需要使用不同的有效载荷来触发，同时需要使用不同的监控方法进行监测。这些要求使FWSR的设计更加困难。

**我们的方法**

​		在本文中，我们提出了一种针对FWSR的基于物理设备的自动化模糊测试框架，以解决上述挑战。它通过自动生成种子和自动控制电源来持续驱动模糊测试过程。为了建立输入语义模型，它利用了两个模型来约束测试用例，即KEY-VALUE数据模型（简称K-V模型）来描述请求的内部数据格式，以及CONF-READ通信模型（简称C-R模型）来描述请求的时间序列。此外，我们的框架通过将不同的变异规则与多个监控机制协调起来，以有效地触发四种类型的漏洞，即内存损坏漏洞、命令注入漏洞、跨站脚本攻击（XSS）和信息泄露漏洞。据我们所知，这是第一个针对FWSR的全过程全自动化框架。此外，通过一些人力工作来收集Web请求和监测运行状态，它可以超越全自动化模糊测试。

​		首先，为了自动生成种子，我们的框架使用基于爬虫的方法从运行的设备自动收集Web请求头和请求内容[20]。同时，为了使设备从“僵尸”状态恢复，我们添加了一个基于Wi-Fi插头的电源控制模块，并在设备卡住时强制重新启动。此外，我们的框架直接对物理设备进行测试。这个设计决策是通用且实用的，因为它不需要模拟许多路由器不可行的固件。

​		其次，我们的框架可以在无需固件逆向工程或插桩（基于反馈引导模糊技术所需要[43]）的情况下触发更深层次的漏洞。相反，该框架通过精确地对数据格式和请求序列进行建模，使用K-V模型和C-R模型分别对真实输入进行变异。相反，该框架在精确建模数据格式和请求序列的帮助下，分别使用K-V和C-R模型对真实输入进行变异。通过K-V模型，我们能够区分值的数据类型，并分配不同的变异规则。通过C-R模型，我们可以构造多阶段通信，以触发某个特定运行状态下的漏洞。

​		第三，针对不同类型的漏洞，我们将其归纳为数据不一致性漏洞。为了发现它们，我们将变异与监控相结合。更具体地说，我们设计了六个变异规则和三个监控机制。在模糊测试一个给定类型的漏洞时，我们选择适当的变异规则和监控机制。

​		我们已经实现了我们解决方案SRFuzzer的原型，并将其部署在实际环境中。为了评估其有效性和普适性，我们在5个供应商的10个流行路由器上运行了SRFuzzer。受益于全面的新监控方法，我们得到了208个独特的异常行为。几乎一半的异常行为被确认为属于上述四种漏洞类型的101个独特问题。在向相应供应商负责披露漏洞后，我们共获得了97个分配的ID，即：43个CVE ID、52个PSV ID和2个CNVD ID。

**贡献**。本文的贡献如下：

- 我们提出了一个完全自动化的模糊测试框架，用于发现FWSR的各种漏洞。我们通过自动生成种子并自动恢复设备来持续驱动模糊测试的进行。
- 我们设计了KEY-VALUE数据模型和CONF-READ通信模型来揭示漏洞产生的根本原因并指导变异，并将六个变异规则与三个监控机制协调起来，以提高漏洞发现的有效性。
- 我们实现了一个名为SRFuzzer的原型，并在10个实际的SOHO路由器上进行了评估。它在208个独特的异常行为中总共发现了101个被确认的问题，其中97个被供应商确认为0day漏洞。结果表明，SRFuzzer在漏洞发现能力方面优于现有的解决方案。

​		本文的组织结构如下：第2节介绍我们克服挑战的动机和见解。第3节概述了SRFuzzer并描述了详细设计。第4节介绍了实验和评估。第5节和第6节讨论了我们框架的缺点和相关工作。最后，在第7节中进行了总结。

##  2 动机

​		SRFuzzer的设计目标是为FWSR构建一个自动化的模糊测试框架，并尽可能多地发现漏洞。基于固件仿真构建框架似乎很直观，但是由于路由器内置的各种专用组件的多样性，这种解决方案通常非常困难。我们认为，直接自动模糊测试物理SOHO路由器将构建一个通用的框架，尽管仍然具有挑战性。

​		本节中，我们首先介绍我们关注的漏洞类型以及环境假设。然后，我们总结了自动模糊测试实际路由器时所面临的设计挑战，并深入分析了基于C-R和K-V模型的路由器漏洞根本原因，通过一个具体的例子进行了说明。

### 2.1 范围和假设

​		除了网络服务外，为了管理和配置，Web服务也被集成到SOHO路由器中。它们通常由标准协议提供，包括超文本传输协议（HTTP）、简单对象访问协议（SOAP）、通用即插即用协议（UPnP）等。这些协议是由供应商实现的，用于设置Wi-Fi密码、查找终端设备等。我们将这些协议称为管理协议，并在本文中重点关注HTTP协议。此外，我们假设SOHO路由器使用内置的WAN/LAN Web服务作为默认设置，而不是移动到Web服务[11]。

​		一个SOHO路由器典型的管理协议实现由三个主要部分组成，即前端、后端和数据库。前端显示路由器的当前设置并指导用户进行配置。后端解析来自前端的请求并配置相关服务。数据库将当前配置存储在多个位置，例如NVRAM、数据库和配置文件中。图2从CONF和READ操作的角度描述了这些部分的工作流。

[![pCKGco4.png](https://s1.ax1x.com/2023/06/15/pCKGco4.png)](https://imgse.com/i/pCKGco4)

​		图2还显示了工作流中的四种典型漏洞类型。内存损坏和命令注入漏洞通常发生在后端，而XSS漏洞通常发生在前端。信息泄露漏洞可能发生在前端和后端。不同类型的漏洞可以由各种原因触发，例如，内存损坏通常是由于不正确的用户输入处理而触发的。本文中的信息泄露是指在没有适当许可的情况下访问特权数据。另外两种漏洞是常见的Web漏洞，大多数XSS问题是路由器中的存储型XSS漏洞。

### 2.2 自动化整个模糊测试过程

​		自动化FWSR的最重要的步骤是输入生成和运行恢复。如前所述，不同设备厂商的Web服务器实现也不同，这意味着对每个服务器的请求格式也不同。因此，我们选择基于变异的模糊测试，因为很难采用通用的基于生成的模糊测试。为了自动收集种子，这对于基于变异的模糊测试至关重要，我们设计了一个爬虫来获取尽可能多的请求。同时，与Web服务的交互应该仔细处理，以保持服务器的正常运行。这些请求将按照特定规则进行变异，将在第2.3节中讨论，并被馈送到一个物理的SOHO路由器中。

​		一旦一个特定的测试用例使服务器崩溃，SRFuzzer应该观察到这种情况并驱动模糊测试进入下一个测试。在通常，计算机系统上进行模糊测试软件时，重新启动或恢复崩溃的进程通常相对较简单。相反，在没有人为干预的情况下重置或重新启动卡住的SOHO路由器并不容易。在模糊测试过程中，路由器会陷入“僵尸”状态，主要有两个原因。首先，当Web服务器的进程由于畸形请求而崩溃时，可能没有响应返回。其次，如果遇到特定的异常情况，某些设备的自我保护机制会禁止访问Web服务器。

​		为了实现Web服务器的自动重启，我们利用电源控制设备来管理SOHO路由器。具体而言，我们使用了现今广泛使用的智能插座。个智能插座为一个路由器供电，并由SRFuzzer进行控制。它通过Wi-Fi连接到SRFuzzer上。一旦SRFuzzer监测到卡住的路由器，它通过插座内部API发送插座重启命令，进而重新启动设备。然后Web服务器就可以从崩溃状态中恢复。

### 2.3 深入模糊测试

​		覆盖率导向的模糊测试技术，例如AFL [43]，在很大程度上增强了传统的基于变异的模糊测试。由于需要对代码进行插桩，它们对于实际的专用设备来说是不可行的。此外，路由器漏洞的根本原因是请求处理期间数据不一致，这使得FWSR的有效性几乎无法通过这些技术得到提高。我们设计了一个KEY-VALUE数据模型和CONF-READ通信模型来描述请求的语义，即请求中内部数据的格式和不同请求之间的关系，并指导变异规则的设计。我们提供了一个激励性的例子，以更具体的方式说明这些模型。

​		**激励的例子。**为了说明变异规则的设计挑战，我们通过HTTP请求展示了网络时间协议（NTP）的配置过程。图1的左半部分显示了一般过程，图3显示了与该过程相关的后端处理过程。

[![pCKXyRK.png](https://s1.ax1x.com/2023/06/15/pCKXyRK.png)](https://imgse.com/i/pCKXyRK)

​		通常有三个步骤来配置路由器的NTP选项：（i）路由器管理员通过URL发送HTTP GET请求访问配置网页，例如：http：//192.1 68.0.1/apply.cgi/NTP_debug.htm。他/她还获取ntpserver1的当前域名，该域名由图3中第9-13行显示的`read_ntpserver1()`函数使用。我们称此过程为READ操作。（ii）管理员通过发送HTTP POST请求来修改域名。ntpserver 1的新域名通过后端程序`conf_ntpserver1()`提交并存储到数据库中。我们称此过程为CONF操作。 （iii）他/她通过另一个READ操作检查新提交的域名是否被正确配置。

[![pCKXsG6.png](https://s1.ax1x.com/2023/06/15/pCKXsG6.png)](https://imgse.com/i/pCKXsG6)

​		**Key-Value数据模型。**假设当前配置过程处于CONF操作，原始请求如图4上半部分所示。后端处理请求的方式如图3中第3、6、7行所示，并且发生了命令注入问题。函数`conf_ntpserver1()`会从请求中匹配字符串“ntpserver1”，然后获取一个域名。该域名作为`/usr/bin/config`命令的参数，并由`system()`依次执行。然而，如果请求包含类似“ntpserver1=;reboot;”这样的字符串，则会发生命令注入，之后shell命令“reboot;“将在执行`/usr/bin/config`命令后调用。

​		触发此漏洞的输入需要两个条件，即“ntpserver1=”字符串保持不变，且`config`命令的格式保持有效。因此，在原始请求上执行随机变异以生成测试用例在这种情况下可能是无意义的。

​		为了在READ和CONF操作中生成有意义的测试用例，我们设计了KEY-VALUE数据模型来描述单个请求上的约束。每个请求都应该由键值对（简称k-v对）组成，其中key代表变量名，如“ntpserver 1”，并保持不变。值可以分配给变量，因此它应与键的类型要求保持一致。例如，如果键需要“域名”，则值应精确地为域名。尽管原始请求可能采用其他数据格式，例如json和xml，但该模型仍能正常工作。

​		我们通过在k-v对上标记值的属性来描述键和值之间的一致性。我们总结了三种类型的属性：数字、固定字符串和可变字符串。这些属性指导k-v对的值进行变异。因此，在从原始请求解析k-v对并标记属性之后，可以更有效地生成种子。

​		**CONF-READ通信模型。**图3中显示的另一个漏洞是基于堆栈的溢出。该溢出存在于`read_ntpserver1()`函数的第12行，该行在使用ntp之前没有检查其长度。要注意的是，在`conf_ntpserver1()`函数的第3行中设置了ntp的值，它的长度约束与变量info的长度不一致。因此，从数据库中阅读格式错误的域名时可能会触发该漏洞，该域名在第7行中设置，长度在0x50和0x80之间。

```python
这段代码使用sprintf()函数将字符串格式化输出到info数组中。具体来说，它将字符串"ntpserver="和ntp指针变量所指向的字符串拼接起来，然后将结果存储在info数组中。这个字符串的格式为"ntpserver=xxx"，其中"xxx"是ntp字符串的值。通过这样的方式，可以将ntp字符串的值赋给info数组。
```

​		在这种情况下，单个请求不足以触发漏洞，因此我们设计了CONF-READ通信模型来形成多个请求的测试输入。该模型由两个相关的操作组成，即CONF操作和READ操作。在CONF操作中，构造设置或修改设备配置的请求，而在READ操作中，构造获取相应配置的请求。通过这种方式，可以形成多个请求的序列来测试系统的安全性。

​		**经验教训。**通过对图2中配置工作流程和示例的分析，我们得出了漏洞的根本原因是数据不一致。与键ntpserver 1不一致的值导致在CONF操作时触发的命令注入。同时，`conf_ntpserver1()`和`read_ntpserver1()`之间的长度不一致导致在READ操作时触发的内存损坏。通过将K-V模型与C-R模型耦合，SRFuzzer可以揭示k-v配对数据和时间相关请求中的数据不一致性。因此，它能够检测到SOHO路由器Web服务器中的深层次bug。

### 2.4 发现多种类型的漏洞

​		在这个模糊测试框架中，发现和触发CONF或READ操作中的多种类型漏洞是必要的，但也非常困难。正如第2.3节中所述，我们可以根据K-V模型设计各种变异规则。特别是对于具有“可变字符串”属性的值，我们设计了不同的变异规则，以触发溢出，空指针解引用，命令注入和存储XSS的异常行为。此外，我们建立了不同类型的通信方式来触发在CONF或READ操作中出现的漏洞。

​		一旦在设备中触发了漏洞，就会出现一些异常行为，例如后端崩溃、异常响应或执行意外的命令。要监视后端的漏洞，仅使用活性检查[32]是不够的，这是用于监视专用设备的最常见方法。该方法仅通过检查连接状态来监视异常行为。实际上，正常的连接状态（例如HTTP中的状态代码200）并不总是表示正常的行为，例如触发注入命令执行也可以返回正确的连接状态。

​		我们设计了两种通用的监视机制来捕获异常行为，即基于响应的监视器和基于代理的监视器。响应式监视器不仅检查连接状态，还检查可能包含额外信息的响应内容。代理式监视器接收目标路由器的网络访问。受[11]的结论启发，我们还设计了一个可选的基于信号的监视器。它可以捕获更多的内存损坏（即静默内存损坏[32]），但需要在设备中植入一个编译后的可执行文件。通过将变异规则与监视机制相结合，我们可以检测到多种类型的漏洞。

```python
静默的内存损坏（Silent Memory Corruption）是指发生在计算机系统中的一种内存数据损坏，其不会被内存错误检测机制所检测到，而且不会导致系统的崩溃或错误的执行结果。静默的内存损坏可能会对系统的稳定性和安全性造成潜在的威胁，因为它们可能会影响程序的执行流程、数据的准确性和完整性。静默的内存损坏通常是由硬件故障、软件缺陷、电磁辐射等因素引起的。为了避免静默的内存损坏对系统的影响，需要采取有效的内存错误检测和纠错措施。
```

## 3 详细设计

​		在本节中，我们介绍SRFuzzer的详细设计。如图5所示，SRFuzzer由五个模块协同工作。一旦连接到路由器，它通过种子生成器模块收集有效的种子。然后，它将种子输入到变异器模块中，根据各种变异规则生成变异请求。最后，SRFuzzer通过变异器、监视器和电源控制模块的协作，触发并监控异常行为。

[![pCKX6xO.png](https://s1.ax1x.com/2023/06/15/pCKX6xO.png)](https://imgse.com/i/pCKX6xO)

1. **种子生成器。**为了生成初始的测试用例，即种子，用于变异，种子生成器通过请求收集子模块收集原始请求，并将其解析成k-v对。然后，它为所有的k-v对打上属性标签，这些标签可以指导后续的变异。请求收集子模块由两部分组成，一个是作为默认设置的常规爬虫，用于自动收集请求，另一个是可选的被动爬虫，用于通过与用户交互来收集更多请求。

2. **变异器。**变异器通过两个子模块——变异选择器和模式选择器的协作，为SOHO路由器生成变异请求。在K-V模型的指导下，根据每个k-v对的属性和被发现的漏洞类型，选择变异规则并将其应用于每个k-v对的值。在模式选择器子模块中，基于C-R模型决定请求的类型和顺序。模式选择器可以生成一个请求，类型为CONF操作或READ操作。同时，它也可以生成一系列请求，例如在CONF操作后进行READ操作。

3. **监视器。**为了与变异器模块紧密协作并监视更多的异常行为，监视器模块由两个常见的监视器组成，即一个基于响应的监视器和一个基于代理的监视器。基于响应的监视器通常可以监视三种类型的漏洞，即内存损坏、XSS和信息泄露。需要注意的是，对于信息泄露漏洞，它监控的是没有足够访问权限的目标URL的响应。基于代理的监视器用于命令注入和XSS漏洞。此外，还提供了一个可选的基于信号的监视器来捕获更深层次的内存损坏。它是基于ptrace syscall开发的，可以监测信号，如SIGSEGV和SIGABRT。

   ```python
   ptrace是一个用于进程跟踪和调试的系统调用。它允许一个进程监视和控制另一个进程的执行。ptrace系统调用可以用于实现调试器、进程监控工具、进程间通信等应用。通过ptrace系统调用，一个进程可以读取或写入另一个进程的内存、寄存器和栈信息，还可以截获和处理进程接收到的信号。在Linux系统中，ptrace系统调用是非常重要的系统调用之一，它为系统调试和安全监控提供了基础支持。基于信号的监视器是使用ptrace系统调用开发的，它可以监测到程序因内存错误导致的信号，SIGSEGV（段错误）和SIGABRT（程序异常中止信号）。
   ```

   

4. **电源控制。**为了持续对物理路由器进行模糊测试，引入了一个电源控制模块。它由智能插座支持，用于控制设备的电源。该模块由监视器模块控制。如果后端服务陷入“僵尸”状态，即无响应，控制命令将被发送到插座，设备将被重新启动。

5. **配置。**为了提高模糊测试的效率，我们还为各个模块提供了自定义配置。所有这些配置都是可选的。我们为常规爬虫配置默认门户的IP地址。我们还提供了变异增强技术，用于具有可变字符串属性的值，以触发更多的异常行为。为了简化基于信号的监视器的部署，我们开发了一个用于路由器的植入工具包。通过这个工具包，我们可以自动将基于信号的监视器置于设备中。

### 3.1 种子生成

​		该模块旨在生成用于后续模糊测试的种子。我们使用请求生成器来收集原始请求，然后将它们存储到请求数据库中。最后，我们利用Key-Value解析器将请求解析为带有属性标签的k-v对。

​		正如我们在第2.3节中提到的，典型的CONF操作是Web通信的第二步，如图4所示。请求收集子模块旨在重复此步骤并通过两个爬虫捕获原始请求。默认情况下，SRFuzzer使用通用爬虫自动收集请求。然而，可以通过被动爬虫来提高收集效果。

​		通用爬虫使用默认的URL作为输入，然后通过解析网页的输入元素自动填充网页。同时它识别页面上的所有URL，并像传统爬虫一样递归地填充它们。它还将请求存储到请求数据库中。如果在爬取过程中需要交互，例如提供特定信息，SRFuzzer会从预定义的数据库中随机选择数据以继续爬取。

​		被动爬虫是一个半自动的工具包，它打开一个网页并等待用户输入来填充网页。在提交配置后，被动爬虫将请求存储到请求数据库中，并准备下一个网页。这样的爬虫通常用于从具有用户输入的网页（例如登录页面）生成种子。

​		此外，为了收集尽可能多的原始请求，并促进后面的属性标记过程，两个爬虫均会填充同一个网页十次。

​		正如前面提到的，K-V模型以细粒度的方式描述了管理协议。然而，我们可以从k-v对中挖掘更多信息以进行更深层次的模糊测试。KEY-VALUE解析器分析原始请求并将其拆分为k-v对。同时，它根据所有k-v对的值标记所有k-v对的属性。

​		在后端的值处理过程中有两个特点。该值通常被处理为可变字符串，并且后端解析关键信息以构建相关配置。其次，通常有一些有效性检查，例如判断一个值是数字还是固定字符串。因此，如果一个固定字符串发生变异，检查就无法通过，由检查保护的代码变得无法访问。因此，我们使用三种类型属性对k-v对进行标记，即数字、固定字符串和可变字符串。k-v对的属性决定应用于k-v对的变异规则。默认情况下，所有k-v对都标记为“可变字符串”属性。算法1展示了k-v对的属性标记过程。

[![pCMP0dU.png](https://s1.ax1x.com/2023/06/16/pCMP0dU.png)](https://imgse.com/i/pCMP0dU)

​		总之，种子生成器将每个唯一的原始请求转换为多个种子。每个种子包含URL和数据元组集，每个数据元组包含一个键、一个值和属性。图4展示了从原始请求到种子的转换过程。

### 3.2 变异 

​		从第2.3节中我们知道，触发漏洞最关键的因素是变异后的值。构建变异规则有两个指导方针。首先，漏洞的根本原因是数据不一致，特别是对于变量字符串。因此如何对每个k-v元组的值进行变异就显得更为重要。其次，不同类型的漏洞之间存在明显的差异，因此变异规则应根据漏洞的类型触发异常行为。

[![pCMPBoF.png](https://s1.ax1x.com/2023/06/16/pCMPBoF.png)](https://imgse.com/i/pCMPBoF)

​		算法2展示了每个种子的变异算法。我们将元组和URL的变异分开，因为将它们一起变异效率低下。为了变异种子，我们从每个种子中随机选择元组的数量。据每个元组的属性，我们使用相关的变异规则来变异其值。数字和固定字符串属性的变异规则很简单，而对于可变字符串，则有四个变异规则来触发不同类型的异常行为：

1. **对于溢出：**为了触发溢出漏洞，该框架通常会将原始值复制多次。如果键的值为空，则从预定义的数据库中选择随机数量的有效负载来填充键。

2. **对于空指针解引用漏洞：**对于具有非空值的键，此框架提供空值以触发潜在的空指针解引用漏洞。

3. **对于命令注入漏洞：**为了适配基于代理的监视器，SRFuzzer使用基于ping或wget等内置工具的畸形有效负载构造值。如果触发命令注入，这些有效负载将连接到包含代理服务器的外部基于代理的监视器。如果该监视器捕获了从路由器发送的请求，它将收集有关异常行为的详细信息。它还可以帮助高效地定位漏洞，以进行后续分析。

4. **对于存储型XSS：**构造XSS有效负载有两个规则。最常见的有效负载包含用于弹出消息框的格式错误的JavaScript代码。如果基于响应的监视器捕获到包含前缀为“xss_”的字符串的消息框，它将记录异常并定位漏洞元组。为基于代理的监视器构造的其他有效负载与命令注入的规则类似，例如“<script>(new Image()).src= "http://PROXY_SERVER/MUTATION_KEY_INFO/" </script>”。

   ```python
   这段代码是一个有效负载，用于触发存储型XSS漏洞的检测。它包含了一个JavaScript代码块，其中创建了一个新的Image对象，并将其src属性设置为一个特定的URL，该URL包含了代理服务器地址和变异键信息。当该有效负载被注入到目标网页中，并且用户访问该页面时，浏览器会尝试加载该URL，从而将变异信息发送到代理服务器，以便进行进一步的监测和分析。
   ```

​		对于可变字符串的所有变异规则，我们还使用特殊字符，例如“;”、“$”、空格字符和各种引号，以触发更多的异常行为。这些特殊字符可以帮助绕过后端的有效性检查。例如，`inet_addr（const char *cp）`函数只提取字符串中第一个空格之前的部分，以检查它是否是有效的IP地址。因此，具有“IP+空格+附加字符串”形式的值被错误地认为是有效的IP地址。对于第三和第四个变异规则，我们将键编码到变异值中，以帮助精确定位k-v对。

```python
"encode the key into the mutation value" 的意思是将键（k-v对中的键）嵌入到变异值中，这样在进行后续的检测和分析时可以更容易地定位到具体的 k-v 对。具体来说，我们可以将键与变异值拼接在一起，形成一个新的字符串，例如 "KEY_MUTATION_VALUE"。这样在后续的监测和分析中，当该值触发了异常行为时，可以通过解析变异值，提取其中的键信息来定位到具体的 k-v 对，以便进一步的分析和修复漏洞。
```

​		对于URL变异，该框架在模糊测试时会生成包含权限之外的特殊路径或敏感文件路径的URL，例如 `/etc/passwd` 或 `/etc/shadow`。如果可以通过正常响应访问格式错误的URL，则基于响应的监视器会将其报告为异常行为。这些畸形URL通常是超出正常权限范围的，因此如果可以成功访问，则可能会暴露系统中的漏洞。

​		表1展示了这些规则如何应用于图4所示的示例。原始值为`http://DEVICE_IP/apply.cgi?/NTP_debug.htm`和`time.test1.com`。

[![pCMi6AS.png](https://s1.ax1x.com/2023/06/16/pCMi6AS.png)](https://imgse.com/i/pCMi6AS)

### 3.3 异常行为的触发与监控

​		设备常用的模糊测试方法是在发送变异数据包后监视响应状态。此过程中只有一次通信。但是，这种方法只对C-R模型中的CONF操作中出现的漏洞有用。我们还需要触发在READ操作中出现的漏洞。为了克服这个限制，我们在CONF操作之后立即触发READ操作。我们还将请求阶段和监视方法分开。此外，我们在每个通信周期后使用原始值回滚CONF操作。

​		正如我们在2.4节中提到的，由于“活性检查”仅限于来自响应的有效信息，因此它很难监控各种类型的漏洞，也无法捕获更深层次的异常行为，例如子进程中发生的内存损坏。为了弥补其局限性，我们扩展了活性检查到一个基于响应的监视器。此外，我们还设计了基于代理的监控器和基于信号的监控器，以进一步提高监控性能。图6显示了三种典型的监控机制及其监控范围。

[![pCMi5n0.png](https://s1.ax1x.com/2023/06/16/pCMi5n0.png)](https://imgse.com/i/pCMi5n0)

1. **基于响应的监控器：**除了活性检查外，分析通信的响应内容可以监视在前端触发的XSS问题。我们在CONF操作期间为每个要变异的键构造有效负载，并在分离的READ操作期间分析响应内容。然后，我们可以轻松地定位触发异常行为的关键键。此外，还可以通过判断响应状态来监控信息泄露。

2. **基于代理的监控器：**对于命令注入和XSS问题，变异模块构造畸形有效负载以请求路由器外部的服务器。我们在路由器可以访问的本地网络中构建一个监控服务器。因此，当路由器访问监控服务器时，我们可以检测到命令注入和XSS问题。通过与构造的有效负载配合，基于代理的监视器可以有效地定位易受攻击的URL和触发异常行为的关键k-v对。

3. **基于信号的监控器：**对于内存损坏问题，最常见的信号是SIGSEGV和SIGABRT。这两个信号总是在进程甚至子进程崩溃时出现。因此，监视这些信号可以捕获更多真正的异常行为，同时减少误报率。针对基于Linux的路由器，我们可以基于ptrace系统调用开发监视器。

   ```python
   SIGSEGV的全拼是Segmentation Violation Signal，表示段错误信号；SIGABRT的全拼是Abort Signal，表示异常中止信号。
   ```

​		虽然基于信号的监视器可以比基于响应的监视器更广泛和更准确地监视内存损坏，但它需要将二进制文件植入路由器的权限，这并不总是可行的。因此，只有满足权限要求的设备才能利用此监视器。获取该权限有三种方式，即通过调试shell、利用已知的漏洞（例如命令注入）以及连接内置串口。们还开发了一个植入工具包，可以自动将可执行文件放入设备中。

​		由于三个监视器是独立工作的，我们必须同步它们的请求和异常行为。我们为每个请求记录一个时间戳，为每个异常行为记录一个时间戳，以确保请求与异常行为相关。

## 4 实验与评估

### 4.1 实现

​		我们已经用大约12,000行Python代码和500行C代码实现了自动模糊测试框架。

​		对于种子生成器模块，我们使用Selenium实现了一个通用爬虫和一个被动爬虫[35]。对于Monitor模块，我们独立实现了三种类型的监视器。具体来说，基于信号的监视器在C中使用`strace` [39]实现，并在可能的情况下通过设备特性，已知漏洞或串口的帮助植入设备。它使用Buildroot [8]进行交叉编译，作为静态链接的二进制文件。现在，它支持多种架构，包括x86、x86-64、ARM32（LE）、ARM32（BE）、MIPS32（BE）和MIPS32（LE）。

```c
Selenium是一个用于Web应用程序测试的自动化工具，它可以模拟用户在Web浏览器中的行为，例如点击按钮、输入文本等。Selenium可以支持多种编程语言，如Java、Python、C#等，可以在多种浏览器上运行，如Chrome、Firefox、Safari等。在Web应用程序的开发和测试中，Selenium广泛应用于自动化测试、功能测试、回归测试等方面。
```

```C
strace是一个用于跟踪和调试Linux系统调用的工具。它可以监视进程在执行时调用的系统调用，并将其输出到终端或指定的文件中，从而帮助开发人员和系统管理员诊断和解决问题。strace可以用于跟踪应用程序的系统调用、查找应用程序的性能瓶颈、调试共享库、查找应用程序的错误等方面。strace使用简单，常用的命令有strace -p pid （跟踪指定进程）、strace -c （统计每个系统调用的次数和时间）等。
```

```C
交叉编译是指在一种CPU架构的主机上，使用一组工具链（如编译器、链接器等）来生成另一种CPU架构的目标代码。例如，在x86架构的主机上使用工具链来生成ARM架构的目标代码。交叉编译通常用于嵌入式系统开发中，因为嵌入式设备通常使用的处理器架构与常见的PC机不同。通过交叉编译，可以在开发机上编译出适用于目标设备的二进制程序，大大简化了开发和调试的过程。交叉编译需要使用特定的交叉编译工具链和配置文件，以确保生成的目标代码能够在目标设备上正确运行。
```

​		为了在设备挂起时重新启动设备，SRFuzzer首先通过尝试重复建立与目标设备的TCP连接来监视设备状态。如果TCP连接多次无法正常建立，则通过电源控制模块重新启动设备。我们基于Mi Smart Plug [2]在python-miio [34]协议的帮助下实现了这个模块。

### 4.2 实验设置

​		在实验中，我们选择了来自五个不同厂商的10个设备进行测试。表2展示了它们的信息。表格的最后一列显示了每个设备支持的获取植入基于信号的监视器权限的方法。

[![pCM2bIH.png](https://s1.ax1x.com/2023/06/16/pCM2bIH.png)](https://imgse.com/i/pCM2bIH)

​		除了基于信号的监视器外，SRFuzzer的所有模块都部署在Ubuntu 16.04上。它通过有线连接与路由器连接，并通过稳定的无线连接连接到Mi Smart插座。SRFuzzer对每个设备进行连续40小时的模糊测试。在模糊测试过程中，如果电源控制模块超过六分钟未收到任何响应，则会重新启动设备。

### 4.3 整体实验

​		我们总共监测了208个独特的异常行为。借变异模块添加的额外信息，我们确认了101个独特的问题，并手动完成了相应的PoC。它们的详细信息显示在表3的最后一列中。

[![pCM2Lid.png](https://s1.ax1x.com/2023/06/16/pCM2Lid.png)](https://imgse.com/i/pCM2Lid)

```C
For memory corruption, the PoC can cause the backend crash or hijack its control flow. For command injection, the PoC can execute a shell command such as “reboot”. For XSS, the PoC can eject a message box in the browser with the content “Hello, XSS.”. For information disclosure, the PoC can disclose some sensitive information.
```

​		在根据负责的披露政策向相关供应商报告后，101个独特问题中的97个已得到其供应商的确认，另外4个问题正在评估过程中。这97个漏洞被分配了官方ID，其中包括43个CVE ID、52个PSV ID和2个CNVD ID。

**已确认的问题。**对于每个设备，SRFuzzer收集的种子数量在第2列中给出，每种类型的问题（即内存破坏、命令注入、跨站脚本和信息泄露）在两个触发阶段（即CONF和READ）中分组的问题数量在第3-8列中给出。在101个确认的问题中，有48个问题是内存破坏（占47.52%），其余包括39个命令注入问题（占38.61%）、9个跨站脚本问题（占8.91%）和5个信息泄露问题（占4.95%）。有67.33%的问题在CONF操作中触发，32.67%在READ操作中触发。除了TL-WVR900G外，所有确认了超过10个问题的设备都发现了多种类型的漏洞。经过分析其实现，我们发现其后端是使用Lua语言实现的，这可以避免内存破坏问题。

​		此外，我们评估了97个官方确认的漏洞的影响，这些漏洞来自CVSS版本3评分[1]及其影响，如图7所示。我们使用基于CVSS分数的官方四个等级来显示漏洞的严重程度。具体而言，超过四分之一的问题（25/97）属于高级别。我们还根据漏洞的影响效果，即提权（EoP）、脚本执行、拒绝服务（DoS）和信息泄露，统计了四个类别的问题数量。大部分问题属于提权类别，因为我们可以通过构造PoC来劫持控制流以执行底层系统的命令，从而将Web管理权限提升到root权限。几乎所有的PoC都可以通过发送一条单一消息来攻击目标设备。

[![pCM27ZD.png](https://s1.ax1x.com/2023/06/16/pCM27ZD.png)](https://imgse.com/i/pCM27ZD)

​		**监视器的影响。**不同监视器捕获的不同确认问题的分布如表4所示。我们可以观察到，大部分确认的问题（77.23%）都是由基于响应和代理的监视器捕获的，显示了这些与设备无关的监视器的有效性。我们还发现，另外23个问题是由基于信号的监视器捕获的，显示了它发现深度内存破坏漏洞的能力。需要注意的是，基于信号的监视器可以更多地捕获WNDR-4500v3和R7800的问题。这是由于它们的特殊实现。在它们的后端中，它们创建子进程来处理请求，并且当子进程崩溃时，始终回复“配置失败”。在这种情况下，基于信号的监视器可以处理它们，而响应基础监视器则不能。

```C
这是因为在这些设备的后端实现中，它们使用了一个子进程来处理请求。当子进程崩溃时，响应基础监视器会认为设备正常工作并忽略这个故障，而基于信号的监视器可以监测到子进程的异常退出信号并捕获问题。因此，基于信号的监视器可以更好地检测这些设备中的问题。
```

[![pCM2OJA.png](https://s1.ax1x.com/2023/06/16/pCM2OJA.png)](https://imgse.com/i/pCM2OJA)

```C
R表示基于响应的监视器。S表示基于信号的监视器。P表示基于代理的监视器。N/A表示器械不支持该监测方法。
```

​		图8显示了SRFuzzer报告的独特异常行为数量与我们确认的问题数量的比较。在这个实验中，我们独立运行每个监视器。在这个实验中，我们独立运行每个监视器。因此，一些确认的问题被不同的监视器捕获，如图8所解释的那样。平均而言，我们的监视器的准确性为48.56％。所有类型的漏洞的准确性都高于40.00％，除了信息泄露，这非常有前途。

```C
与表4相比，基于信号的监测器多了23个已确认问题，基于响应的监测器多了3个已确认的XSS问题。它们都是重复的问题，可能被其他监视器捕获。
```

[![pCM2Hde.png](https://s1.ax1x.com/2023/06/16/pCM2Hde.png)](https://imgse.com/i/pCM2Hde)

**重新启动。**每个设备在模糊测试期间重新启动的次数如图9所示。在我们的测试中，40小时内每个设备平均重新启动了6.8次。有趣的是，R8500重新启动的次数是R7800的3.6倍。这是因为R8500只在一个进程中处理所有请求，而R7800通过创建子进程来处理请求。此外，基于Openwrt操作系统的设备（例如TL-WVR900G）比其他设备更稳定。

[![pCM2IsK.png](https://s1.ax1x.com/2023/06/16/pCM2IsK.png)](https://imgse.com/i/pCM2IsK)

### 4.4 对比

​		我们将SRFuzzer与三个流行的开源模糊测试工具进行了漏洞发现方面的比较。对于内存破坏漏洞，我们选择了boofuzz [27]，这是著名协议模糊测试工具Sulley [21]的分支和继承者。对于命令注入漏洞，我们选择了Commix [37]，而不是boofuzz，因为Commix具有更多的变异规则和监视方法，可以更好地处理命令注入漏洞。对于XSS漏洞，我们选择了wfuzz [28]，这是一款流行的Web模糊测试工具，支持XSS检测。由于信息泄露漏洞的大部分结果（5个中的4个）正在评估中，因此我们将在未来的工作中进行比较。

​		在比较中，选择了四个厂商的七个设备。在这些设备上，我们运行了所有工具，持续40个小时，与SRFuzzer相同。我们使用了与SRFuzzer相同的原始请求作为输入。为了满足boofuzz的特殊输入要求，我们将每个具有k-v对的种子转换为boofuzz的数据表示形式。如图10所示，SRFuzzer在所有类型的漏洞中均优于这三个比较工具。具具体来说，它发现的内存损坏问题比boofuzz多53.57%，命令注入问题比Commix多25.81%同时，SRFuzzer比wfuzz多发现了一个XSS问题。我们将在细节上分析这些结果。

[![pCM2oqO.png](https://s1.ax1x.com/2023/06/16/pCM2oqO.png)](https://imgse.com/i/pCM2oqO)

**内存破坏。**boofuzz使用其默认的数据表示形式无法发现任何漏洞。我们将包含k-v对的种子编码为boofuzz的数据表示形式。通过这种方式，boofuzz可以有效地变异请求内容字段并触发漏洞。但是，由于缺乏多个监视方法，boofuzz可能会错过在READ操作和子进程中发生的问题。

**命令注入。**Commix的真阳性小于SRFuzzer的真阳性，原因有二。首先，在其许多监视方法中，“与时间相关”的注入监视技术适用于这些设备。但是，该技术依赖于响应时间，这使得Commix错过了一些短时间的异常情况。次，Commix只监视CONF操作期间的异常情况，这使得它忽略了在READ操作中发生的问题，例如AC9和TL-WVR900G中的问题。

**跨站脚本攻击（XSS）。**SRFuzzer比wfuzz多发现了一个XSS问题。它出现在R8500中。wfuzz错过了这个问题，因为生成的输入不能在没有K-V模型的指导下绕过后端有效性检查。因此，精心制作的值无法通过CONF操作成功存储，并且返回给前端的值没有触发XSS问题。

## 5 讨论

​		在这一部分中，我们讨论了当前模糊框架的局限性，并探讨了未来的改进方向。

​		**范围的限制。**只有其管理协议符合C-R模型和K-V模型的物联网设备可以利用SRFuzzer。我们将扩展我们的工作，以应用更多类型的设备，如摄像机、交换机和打印机，以及其他广泛使用的管理协议，如SOAP。

​		**漏洞的严重性。**尽管SRFuzzer可以在没有身份验证的情况下模糊测试设备，但在我们的实验中没有发现任何预身份验证问题。因此，我们将更彻底地检查攻击面，以发现隐藏的接口，以增强发现身份验证绕过漏洞的能力。

​		**数据不一致性研究。**基于C-R模型和K-V模型，我们注意到对于特定的k-v对，在不同的后端程序之间存在若干数据不一致。在本文中，我们专注于自动模糊化的过程中，留下的语义相关性的分析系统为未来的调查。

​		**监控。**从监控的角度来看，SRFuzzer利用了两个方面的优势：针对不同类型漏洞的各种监视器和针对同一类型漏洞的各种监视机制。我

## 6 相关工作

​		有许多关于检测IoT设备漏洞的研究，这些研究也可能适用于SOHO路由器。A. Costin等人[13]对固件映像进行了大规模分析，但在运行时未发现任何问题。H. Bojinov等人[7]审计了几种嵌入式管理界面，B. Gourdin等人[24]提出了WebDroid来构建安全的嵌入式Web界面。也有类似的针对SOHO设备的工作[25]，[17]。另一种大规模漏洞检测的方法是扫描互联网上的易受攻击的设备。A. Cui [14]在全球范围内提出了易受攻击的嵌入式设备数量的量化下限。他们发现超过54万个嵌入式设备配置了出厂默认的root密码。

​		模糊测试是自动发现漏洞的有效方法。反馈驱动的模糊测试器[9]，[22]，[23]，[31]，[43]，[33]使用运行时代码覆盖率来指导后续输入的生成。You [41]，Jain [26]研究了输入字节的自动类型推断。模糊测试过程可能会卡在具有复杂条件的特定分支处。为了解决这个问题，研究人员将模糊测试与符号执行[10]，[30]，[38]相结合。虽然这些方法很有前途，但由于缺乏内部运行时信息，它们不适用于路由器。

​		仿真设备是获取运行时信息的潜在解决方案。A. Costin等人[12]使用qemu来模拟某些基于Linux的设备的Web界面。该方法无法用于包含特殊硬件相关操作（如Wi-Fi配置）的Web界面。FIRMADYNE [15]通过支持设备的NVRAM仿真来模拟基于Linux的COTS固件。但在我们的实践中，它仅限于基于ARM的设备。

​		为了克服固件获取和仿真问题，提出了在物理设备上进行模糊测试的方法。Z. Wang等人[40]开发了RPFuzzer来对路由器协议（如SNMP）进行模糊测试。IoTFuzzer [11]是一个基于应用程序的模糊测试框架，旨在在没有固件映像的物理IoT设备中找到内存损坏。它利用模糊测试和污点分析的协作。它仅关注移动到Web接口，并通过仅进行活性检查检测内存损坏，这对于发现Web服务器漏洞来说是不够的。此外，M. Muench [32]分析了模糊测试嵌入式设备的挑战，并提出了六个启发式方法来检测内存损坏。

​		程序分析技术也被用于发现IoT设备的漏洞。Q. Feng等人[19]采用了基于图形的方法来搜索固件映像中的漏洞。他们将控制流图转换为数字特征向量，并使用几种哈希技术来实现实时搜索。Y. Shoshitaishvili等人[36]使用静态符号执行和程序切片来查找后门。此外，还使用了动态符号执行。FIE [16]是一个用于查找MSP430固件中的漏洞的符号执行框架。Avatar [42]是一个协调仿真器和设备的框架，用于分析固件。SRFuzzer是这些技术的一个补充。

## 7 总结

​		我们提出了SRFuzzer，以完全自动化的方式识别SOHO路由器的多类型漏洞，而无需进行设备仿真。为了全面深入地发现漏洞，我们设计了KEY-VALUE数据模型和CONF-READ通信模型，以揭示数据不一致性并指导模糊测试。通过六个变异规则和三个监视机制的协作，我们测试了10个物理路由器，并在负责任的披露后被分配了43个CVE ID、52个PSV ID和2个CNVD ID。
