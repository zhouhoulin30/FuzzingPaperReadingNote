TRACER: Signature-based Static Analysis for Detecting Recurring Vulnerabilities

TRACER: 基于签名的静态分析检测重复出现的漏洞

## 1  简介

​		由于开发人员重用现有的易受攻击代码或在实现相同逻辑时犯类似的错误，类似的软件漏洞会反复出现。最近，已经提出了各种分析技术，通过代码重用来发现语法上反复出现的漏洞。然而，对于在不同的代码结构中共享相同易受攻击行为的语义上反复出现的漏洞，却受到了有限的关注。在本文中，我们提出了一种名为TRACER的通用分析框架，用于检测此类重复性漏洞。其主要思想是将漏洞签名表示为跨过程数据依赖的跟踪。TRACER基于一种可以检测各种类型漏洞的污点分析。对于一组已知漏洞，污点分析提取易受攻击的跟踪，并建立一个相应的签名数据库。当分析一个新的未知程序时，TRACER将分析报告的所有潜在易受攻击的跟踪与已知漏洞签名进行比较。然后，TRACER根据相似度评分报告一个潜在漏洞的列表。我们在273个Debian的C/C++软件包上评估了TRACER。实验结果表明，TRACER能够发现112个以前未知的漏洞，并为其中6个分配了CVE编号。

​		随着时间的推移，相似的软件漏洞在不同的程序中反复出现。其中一个众所周知的原因是代码重用的普遍性[23, 26, 33, 34, 47]，这可能导致在重用的代码中传播安全漏洞。除了这种语法上的重复出现，语义上相似的漏洞经常在独立开发的不相关代码库中反复出现。其中一个原因是，开发人员在实现数学公式、物理定律、协议或语言解释器等相同标准概念时经常犯类似的错误[37, 42]。另一个原因是由于编程语言的复杂低级语义（例如C中的未定义行为），常见的误解会导致开发人员编写具有类似错误模式的不正确代码[14]。根据Google最近的一份报告，2020年的24个0-day漏洞中有6个实际上是先前出现漏洞的变体[42]。

​		尽管研究人员已经开发了许多成功的技术来检测重复性安全漏洞，但现有方法在几个方面存在局限性。基于代码相似性的方法[12, 15, 23, 26, 29, 38, 47]旨在通过代码重用来检测重复性漏洞。它们在预定义的边界（例如文件或函数）内生成已知漏洞的签名，并将新程序中的语法模式与这些签名进行比较。这些方法非常精确、可扩展和通用，因为它们的方法基于语法匹配。然而，它们通常无法检测已知漏洞的变体，这些变体具有完全不同的语法结构，但具有相同的根本原因。另一方面，基于模式的静态分析[2, 3, 18]不仅估计目标程序的语义，还考虑它们的语法模式。这使得分析器能够检测具有已知漏洞程序的相似语法和语义特征的漏洞。然而，设计这样的分析需要静态分析的专业知识，并带来了相当大的工程负担。

​		为了解决这个问题，我们着手构建一个有效的软件免疫系统来抵御反复出现的漏洞。我们确定了这样一个系统需要满足的以下标准：

- 准确性：该系统是否准确报告潜在漏洞，具有低误报率？
- 鲁棒性：该系统能否找到具有相同根本原因的漏洞变体？
- 通用性：该系统是否适用于广泛的安全漏洞？
- 可扩展性：该系统是否适用于大型程序？
- 易用性：该系统是否提供易于理解的报告？

​		在本文中，我们提出了一种基于签名的静态分析方法，名为TRACER，用于检测重复性漏洞，并设计满足上述标准的系统。其关键思想是将漏洞签名表示为跨过程数据依赖的跟踪。TRACER基于一种通用的污点分析，旨在检测各种安全漏洞，如整数溢出/下溢、格式化字符串、缓冲区溢出、命令注入等。该分析器检测潜在易受攻击的数据流，从不受信任的输入（称为源）到安全敏感函数（称为汇）的数据流。我们在已知漏洞的代码库上运行静态分析器，并在分析结果中识别实际的漏洞。接下来，TRACER提取从源点到汇点的漏洞的数据依赖关系上的跟踪。这些跟踪被编码为特征向量，形成漏洞的签名。一旦分析一个新程序，TRACER提取程序中所有报告的警报的跟踪，并以相同的方式推导它们的特征向量。然后，TRACER使用常见的相似度度量（如余弦相似度）将警报的特征向量与已知易受攻击跟踪的特征向量进行比较。最后，TRACER提供按相似度排序的警报列表。

​		我们基于Facebook的Infer分析器[5]实现了TRACER，并在一套使用C/C++编写的Debian软件包上展示了其有效性。根据我们对273个Debian软件包的实验结果，TRACER发现了112个与已知CVE、Juliet测试套件[4]中的漏洞示例以及在线安全编码教程中的示例代码类似的重复性漏洞。

​		本文的贡献如下：

- 我们提出了一个通用的分析框架TRACER，用于检测语义上重复的漏洞。TRACER适用于各种漏洞。
- 我们提出了一种基于跟踪的方法来计算漏洞的相似度。我们的方法基于一种通用污点分析报告的警报数据依赖关系。
- 我们在273个Debian软件包上评估了TRACER的有效性。我们发现了112个漏洞，分配了6个CVE标识符。

## 2  概述

### 2.1  激励示例

​		我们通过图1中存在安全漏洞的程序说明我们的方法。这三个程序都存在与某种安全漏洞相关的类似问题：溢出的整数可以作为内存分配函数（如malloc）的大小参数。这种整数溢出会导致程序无意中分配较小的内存块，可能导致缓冲区溢出。

​		图1（a）显示了2009年报告的图像处理工具gimp中的漏洞。该程序从给定文件中读取一个字节字符串（第10行），将该字符串转换为整数（第12行）。由于该值取决于输入文件的内容，因此整数可以是任意大的。由于同样的原因，第13行的整数值也可以是任意大的。然后，程序将这些整数相乘，导致整数溢出（第14行）。最后，溢出的整数（rowbytes）被传递给函数ReadImage，并用作malloc的参数（第21行）。请注意，分配的缓冲区的大小可能远小于开发人员预期的大小。因此，当后续使用缓冲区来存储输入文件的数据时，可能会发生潜在的缓冲区溢出。

[![pidbql6.png](https://z1.ax1x.com/2023/11/23/pidbql6.png)](https://imgse.com/i/pidbql6)

​		在8年后，另一个程序sam2p中发现了一个类似的漏洞，如图1（b）所示。sam2p也是一个图像处理工具，因此它有一段类似的代码用于读取BMP文件。由于与gimp完全相同的原因，该程序也很容易受到攻击。请注意，这段代码片段与gimp的代码非常相似。从概念上讲，基于代码克隆检测的现有方法可以在给定gimp中的漏洞作为签名的情况下捕捉到这种重复性漏洞。然而，在实践中，这有时是具有挑战性的。基于克隆的方法通常在预定义的语法边界（例如函数或块）内比较两段代码。如示例中所示，当易受攻击的行为涉及多个功能时，这反过来会阻碍漏洞检测。最先进的工具[26, 47]会启发式地选择一个包含已知漏洞补丁的漏洞签名函数（在gimp中为ReadBMP）。然而，如果函数很大并且包含相当多的语法差异，这种方法仍然是脆弱的。例如，gimp中的ReadBMP由382行组成，而samp2p中的bmp_load_image只有151行。虽然漏洞的本质是相同的，但它们在其他部分存在许多差异。例如，两个程序中的7-8行完全不同，并且作为C++程序的sam2p使用的是new而不是malloc。

[![pidbbSx.png](https://z1.ax1x.com/2023/11/23/pidbbSx.png)](https://imgse.com/i/pidbbSx)

​		此外，重复性漏洞并不总是由代码克隆引起的。当开发人员编写具有典型或标准行为的程序时，他们经常会犯类似的错误，无论是在低级别（例如从文件中读取数据或分配堆内存块）还是在高级别（例如计算正方形的面积或处理图像文件）。图1（c）显示了来自libXcursor的一个示例。与之前的示例类似，该程序从输入文件中读取数据（第3行），将输入字节字符串转换为整数（第5行），并计算两个任意大整数的乘法（第21行）。乘法也会导致同一行的整数溢出，随后可能导致缓冲区溢出。请注意，漏洞的根本原因与其他示例相同。然而，libXcursor具有完全不同的语法结构。例如，libXcursor在第3行使用间接调用fread，而其他程序直接调用该函数。

[![pidbL6K.png](https://z1.ax1x.com/2023/11/23/pidbL6K.png)](https://imgse.com/i/pidbL6K)

​		现有的方法不适合检测这种语义上重复的漏洞。基于克隆的方法[26, 47]无法有效检测到这种漏洞，即使将gimp或sam2p中的漏洞作为签名。虽然漏洞的本质仍然相同，但是libXcursor的不同代码结构从根本上阻碍了工具的可检测性。针对一般整数溢出的静态漏洞检测工具可能会检测到这种漏洞，但也可能导致很多误报。也可以设计专门针对每个模式的专用静态分析工具。然而，这将增加很高的工程负担，同时产生次优的解决方案。例如，Github的CodeQL中的TaintedAllocationSize检查器是一种先进的基于模式的分析器，但它无法检测到图1中的特定漏洞。

### 2.2  我们的方法

​		现在，我们介绍TRACER如何检测重复性漏洞。我们的方法如图2所示。在本节的剩余部分，我们将解释TRACER的每个组件的过程，并展示在将gimp中的漏洞作为签名的情况下，TRACER如何准确地检测到sam2p和libXcursor中的漏洞。

[![pidj82R.png](https://z1.ax1x.com/2023/11/23/pidj82R.png)](https://imgse.com/i/pidj82R)

**2.2.1 污点分析。**TRACER基于一种通用的污点分析，可以实例化为各种类型安全漏洞的漏洞检测器。该分析计算从不受信任的输入（源）到敏感函数（汇）的潜在数据流，使用简单的污点值抽象域：${\displaystyle\mathbb{T}} = \{\bot_{t},\top_{t}\}$，其中每个元素表示该值未被污染（$\bot_{t}$），可能被污染（$\top_{t}$）。例如，在图1(a)中，分析器可以检测到从`fread`到`malloc`的恶意数据流。

​		为了更准确的分析，可以利用其他抽象域沿着基本污点域来详细说明分析。在我们的实现中，我们使用了一个简单的抽象域$\rm{\bar{I}} = \{\bot_{o},\top_{o}\}$，用于估计一个整数值是否可能溢出（$\top_{o}$）或未溢出（$\bot_{o}$）。例如，一个不可信的输入值最初是被污染的（$\top_{t}$），但未发生溢出（$\bot_{o}$）。一旦该值被用作可能引发整数溢出的运算符操作数（例如+，<<），结果就会变为被污染的（$\top_{t}$）和溢出的（$\top_{o}$）。对于`malloc`的情况，我们的分析器仅在参数的抽象值既被污染（$\top_{t}$）又发生溢出（$\top_{o}$）时发出警报。通过这样做，我们不会报告微不足道的误报，同时高效地计算恶意数据流。我们的实现细节在第4节中进行了描述。

**2.2.2 数据依赖图上的跟踪。**我们在一组已知存在漏洞的程序上运行污点分析。对于每个已知的漏洞，TRACER根据静态分析结果从源点和汇点提取出易受攻击的跟踪。为了尽可能过滤掉与漏洞无关的语句，我们基于数据依赖图而不是控制流图来推导易受攻击的跟踪。一旦污点分析在图1中的gimp和libXcursor中检测到潜在的恶意流，TRACER就会导出数据依赖关系图，并提取从源到汇的易受攻击的跟踪，如图3所示。这样的跟踪将被用作漏洞的签名。

​		同样的过程将应用于新的目标程序。特别是，TRACER从报告的警报中提取出所有可能的从源到汇的跟踪，同时只展开每个循环一次。这些跟踪将与签名跟踪进行比较。

**2.2.3 特征表示。**接下来，TRACER将每个跟踪编码为整数特征向量。我们设计了一个与程序无关且通用的特征空间，可以表示可转移的漏洞知识。我们的特征向量由两部分组成：低级特征和高级特征。

​		低级特征表示跟踪中原始操作符X（例如*，<<）和常见的API X（例如`strlen`）的频率。图3(a)显示了gimp中易受攻击跟踪的特征向量。同样，图3(b)显示了libXcursor的特征向量。

[![piy0nAK.png](https://z1.ax1x.com/2023/12/03/piy0nAK.png)](https://imgse.com/i/piy0nAK)

​		另一方面，高级特征描述了跟踪的详细行为，这些行为仅通过低级特征无法察觉。我们手动设计了5个高级特征。一般来说，它们描述了可以影响目标漏洞的程序关键行为。例如，我们的一个特征`IfSmallerThanConst`检查跟踪中是否存在一个条件语句，其条件形式为`x < c`，其中`x`是一个变量，`c`是一个常数。这种模式在程序中防止整数溢出时很常见。假设目标程序的跟踪中存在这样的表达式，但在签名跟踪中不存在。那么，目标跟踪被认为是安全的，相似度得分会降低。 

**2.2.4 相似度检查。**一旦对一个新程序进行分析，TRACER会提取所有的警报跟踪，并将它们与已知的漏洞签名进行比较。由于所有的跟踪都被编码为向量，我们可以使用任何常见的相似度度量方法。在我们的实现中，我们使用余弦相似度，这是一种用于计算两个向量相似度的著名方法。例如，图3中两个特征向量的余弦相似度计算如下：
$$
\frac{\langle1,3,3,2,1,1,1,1\rangle \cdot \langle1,3,3,2,1,0,0,1\rangle}{\Vert\langle1,3,3,2,1,1,1,1\rangle\Vert ~\Vert\langle1,3,3,2,1,0,0,1\rangle\Vert}=0.96
$$
​		因此，TRACER能够通过高相似度分数精确检测语义上重复出现的漏洞。

### 3  框架

​		在本节中，我们对我们的方法进行了形式化描述。TRACER的整体流程如算法1所示。TRACER首先对目标程序进行分析，并得到一组警报（第1行）。接下来，TRACER计算程序的数据依赖图（第2行）。对于程序的每个警报，算法提取一组跟踪（第5行），并将它们编码为特征向量（第6行）。最后，我们将每个生成的警报$\omega$的特征向量与漏洞签名跟踪进行比较。警报的得分被确定为它们之间的最大相似度得分（第7行）。在本节的剩余部分，我们对TRACER的每个组件的细节进行形式化描述。

$$
\begin{array}
{l}
\hline
	\rm{\bold{算法1：}Tracer(\Pi,\mathcal{A},\mbox{\emph{P}})，其中\Pi是漏洞签名跟踪的特征向量集合，\mathcal{A}是静态分析器，\mbox{\emph{P}}是要分析的程序。}\\
\hline
	1~~\Omega \gets \mathcal{A}(P));\\
	2~~G \gets \rm{build\_dfg}(\mbox{\emph{P}});\\
	3~~R \gets \empty;\\
	4~~\bold{for}~~{\omega \in \Omega}~~\bold{do}\\
	5~~~~~~~~~\mathcal{T}_{\omega} \gets \rm{extract\_traces(\mbox{\emph{G}},\omega)};\\
	6~~~~~~~~~\Pi_{\omega} \gets \{\rm{generate\_feature(\tau)}~|~\tau \in \mathcal{T}_{\omega}\};\\
	7~~~~~~~~~s \gets \max{\{\rm{Sim}(\pi_{\omega},\pi)~|~\pi_{\omega} \in \Pi_{\omega},\pi \in \Pi}\};\\
	8~~~~~~~~~R \gets R\{\omega \mapsto s\};\\
	9~~\bold{return}~~R;\\
\hline	
\end{array}
$$

#### 3.1 程序

​		一个程序被表示为一个控制流图$\langle \mathbb{C},\rightarrow\rangle$，其中$\mathbb{C}$是控制点的集合，$(\rightarrow)\subseteq\mathbb{C}\times\mathbb{C}$是控制流关系。每个控制点都与一个命令相关联。我们假设一个简单的命令式语言，定义如图4所示。一个表达式可以是一个整数、变量、加法操作、减法操作或调用源函数。命令可以是赋值、假设或调用汇聚函数。`source`和`sink`表示读取不可信输入的函数（例如，`fread`），并在敏感的上下文中使用参数（例如，`malloc`）。我们假设每个源点都与一个唯一的标签$l$相关联。

[![pisJKeg.png](https://z1.ax1x.com/2023/12/01/pisJKeg.png)](https://imgse.com/i/pisJKeg)

#### 3.2 通用的污点分析

​		我们提出了一种通用的静态分析方法来进行污点跟踪。该分析的目标是估计从源点到汇点的潜在数据流。该分析可以实例化为一系列适用于常见漏洞类型的污点分析方法，例如整数溢出、格式化字符串或命令注入[20, 21, 44]。我们将在第4节中详细介绍我们实现的具体实例化方法。

​		抽象域如图5(a)所示。对于给定的程序，我们的分析器计算一个抽象状态$(\in\mathbb{S})$，它是从控制点到相应抽象内存的映射。抽象内存$(\in\mathbb{M})$是从变量$(\in\mathbb{X})$到其抽象值的映射。抽象值由两部分组成：污点信息的抽象域$(\mathbb{T})$和值信息的抽象域$(\mathbb{V})$。污点域是源标签的幂集。对于污点检查，我们收集所有可能导致该值的源点。值域表示变量的一般信息。例如，可以定义一个简单的抽象域，它只表示一个值是否溢出，或者定义一个更复杂的域，如区间域。我们的设计选择将在第4节中解释。请注意，值域不是强制性的，但用于提高分析的精度。

​		抽象语义的定义如图5(b)所示。表达式的抽象语义$[[E]]$在给定抽象内存的情况下计算表达式的抽象值。我们假设值域$\mathbb{V}$伴随着一个求值函数$\mathcal{V} : E \rightarrow \mathbb{M} \rightarrow \mathbb{V}$，用于计算表达式的抽象值。常量值$(n)$不被污染，并根据$\mathcal{V}$引入一个抽象值。对于二元运算（+和-），我们合并两个操作数的污点信息，并计算相应抽象运算符的结果。对于源点，分析器将收集用于污点检查的标签，并计算其抽象值。命令的抽象语义$[[C]]$在给定一个抽象内存的情况下计算执行$C$后的抽象内存。

[![piy0e76.png](https://z1.ax1x.com/2023/12/03/piy0e76.png)](https://imgse.com/i/piy0e76)

​		TRACER从分析结果中导出一组警报。污点分析的警报$\omega = \langle c_{1} c_{2}\rangle$是一个包含两个控制点的对，其中$c_{1}$是源点，$c_{2}$是使用源点$c_{1}$中不可信数据的汇点。我们假设分析伴随着一个警报检查函数$Q:\mathbb{C} \rightarrow \mathbb{M} \rightarrow \wp(C)$。从分析结果中给定一个汇点$c$和一个在$c$处的抽象内存$m$，$Q(c)(m)$是从这些源点开始的脆弱数据流到汇点$c$的源点集合。一旦对程序$P$的分析$\mathcal{A}(P)$完成，就可以使用警报检查函数导出一组警报$\Omega$。

​		定义1（警报）。设$\mathbb{C}_{s}$是一个程序的所有汇点的集合。程序的一组警报$\Omega$定义如下：
$$
\Omega = \lbrace \langle c_{1},c_{2}\rangle | c_{2} \in \mathbb{C}_{s}, c_{1} \in Q(c_{2})(m)\rbrace
$$
其中$m$是根据分析结果在$c_{2}$处的抽象内存。

#### 3.3 数据依赖图和被污染的跟踪

​		接下来，我们为输入程序构建一个数据依赖图。给定一个程序的控制流图$\langle \mathbb{C}, \rightarrow \rangle$，数据依赖图被定义为一个元组$\langle \mathbb{C}, \leadsto \rangle$。数据依赖图具有相同的节点集合，但是基于数据依赖关系而不是控制流关系。我们遵循数据依赖的标准概念：
$$
c_{1} \leadsto c_{2} ~\Longleftrightarrow~ c_{1} \rightarrow^{+} c_{2}~\wedge~x在c_{1}处被定义~\wedge~x在c_{2}处被使用~
\\ \wedge~x在c_{1}和c_{2}之间的任何点都没有被重新定义。
$$
其中𝑥是程序变量。这样的数据依赖关系可以在静态分析过程中通过记录关于定义和使用点的附加信息来计算。虽然不考虑控制依赖关系，但我们通过特殊处理条件表达式（如图5(b)中的`assume`操作）来捕获关键的分支条件。我们将在条件表达式中使用的变量也视为已定义的变量。通过这种启发式选择，TRACER可以在实践中捕获重要的步骤，例如边界检查。

​		定义2（被污染的跟踪）。给定一个警报$\omega = \langle c_{0},c_{n}\rangle$，一组被污染的跟踪$\mathcal{T}_{\omega} \subseteq \mathbb{C}^{+}$定义如下：
$$
\mathcal{T}_{\omega} = \lbrace \langle c_{0}, \dots, c_{n}~|~\forall i \in [0,n-1].~c_{i} \leadsto c_{i+1} \rangle \rbrace.
$$
​		一旦建立了数据依赖图，我们就可以提取被污染的警报跟踪。对于每个警报，TRACER都会在数据依赖图上导出从源点到汇点的所有路径。

#### 3.4 特征向量和相似度评分

​		TRACER将每个被污染的跟踪转换为对跟踪特征进行编码的特征向量。我们定义了一组特征，以捕捉关于易受攻击的跟踪的基本知识，在不同的程序中可以重复使用。TRACER使用数值特征$f_{i}:\mathbb{C}^{+} \leftarrow \mathbb{N}$。给定一组$n$个特征$\{f_{1}, \dots f_{n}\}$，TRACER从跟踪$\tau$中提取出一个特征向量：$\langle f_{1}(\tau), \dots f_{n}(\tau) \rangle$。然后，警报$\omega$的特征向量集合$\Pi_{\omega}$定义如下：
$$
\Pi_{\omega} = \{\langle f_{1}(\tau), \dots f_{n}(\tau)~|~\tau \in \mathcal{T}_{\omega} \rangle\}
$$
​		最后，TRACER将程序$P$中警报的特征向量与所有预先计算的已知漏洞特征向量集合$\Pi_{\mathcal{S}}$进行比较。除了只考虑已知的真实警报外，可以使用与前几节中描述的相同步骤导出集合$\Pi_{\mathcal{S}}$。我们还假设存在一个函数$\rm{Sim}:\mathbb{N}^{n} \times \mathbb{N}^{n} \rightarrow \mathbb{R}$，用于计算两个特征向量的相似度。使用相似度函数，将一个警报的得分定义为警报跟踪与签名跟踪之间的最大相似度分数。

​		定义3（警报得分）。给定一个警报$\omega$和一组签名的特征向量$\Pi_{\mathcal{S}}$，警报的得分定义如下：
$$
\max \{ \rm{Sim}(\pi_{\omega}, \pi)~|~\pi_{\omega} \in \Pi_{\omega},\pi \in \Pi_{\mathcal{S}} \}
$$
其中，$\Pi_{\omega}$是警报$\omega$的特征向量集合。

### 4  实例化

​		本节描述了我们系统的详细信息。首先，我们实例化通用的污点分析来检测常见类型的漏洞。我们的实现旨在检测整数溢出、整数下溢、缓冲区溢出、格式字符串漏洞或命令注入。然后，我们解释了我们的特征设计。

#### 4.1 抽象域和语义

​		我们在图6中定义了在我们的实现中使用的抽象域$\mathbb{V}$和函数$\mathcal{V}$。抽象域$\mathbb{V}$由两部分组成：上溢域和下溢域。上溢域$\bar{\mathbb{I}}$（相应地，下溢域$\underline{\mathbb{I}}$）表示值是否可能上溢（$\top_{o}$）（相应地，下溢）或不可能溢出（$\bot_{o}$）。函数$\mathcal{V}:E \rightarrow \mathbb{M} \rightarrow \mathbb{V}$近似于给定表达式和抽象内存的整数上溢和下溢的可能性。常量值$(n)$不会上溢和下溢。对于加法（相应地，减法）运算符，我们保守地近似于可能会上溢的值（相应地，下溢）。

[![pi2NtVx.png](https://z1.ax1x.com/2023/12/08/pi2NtVx.png)](https://imgse.com/i/pi2NtVx)

​		对于五种类型的漏洞，我们使用如下警报检测函数$\mathcal{Q}$：
$$
\mathcal{Q}(c)(m)=\mathcal{Q}_{T}(c)(m) \cup \mathcal{Q}_{O}(c)(m) \cup \mathcal{Q}_{U}(c)(m)
$$
每个子函数的定义如下：
$$
\begin{aligned}
&\mathcal{Q}_{T}(c)(m)=\{ c_{0}~|~c_{0} \in T, \langle T,\_,\_ \rangle = [[E]](m) \}\\
&\mathcal{Q}_{O}(c)(m)=\{ c_{0}~|~c_{0} \in T, \langle T,\top_{o},\_ \rangle = [[E]](m) \}\\
&\mathcal{Q}_{U}(c)(m)=\{ c_{0}~|~c_{0} \in T, \langle T,\_,\top_{u} \rangle = [[E]](m) \}\\
\end{aligned}
$$
​		其中$c$是汇点，$c$处的抽象内存为$m$。如果汇函数的参数被污染，则函数$\mathcal{Q}_{T}$将收集汇点的所有源点。TRACER使用$\mathcal{Q}_{T}$分别来检测`printf`类函数、`exec`类函数和`memcpy`类函数的格式化字符串、命令注入和缓冲区溢出。$\mathcal{Q}_{O}$和$\mathcal{Q}_{U}$还会额外检查参数是否可能上溢和下溢。这些函数用于检测内存分配（例如`malloc`）的恶意使用，其中参数上溢（即意外地过小），以及内存复制（例如`memset`）的参数下溢（即意外地过大）。

#### 4.2 特征与相似性度量

​		我们为受污染的警报跟踪设计了一组特征，如表1所示。这组特征包括两个类别：低级特征和高级特征。

[![piojlxe.png](https://s11.ax1x.com/2023/12/20/piojlxe.png)](https://imgse.com/i/piojlxe)

​		低级特征NumOfOpX和NumOfLibX描述了在跟踪中每个基本运算符X（例如+和<<）和标准库调用X（例如`strlen`和`strcmp`）的频率。例如，图3展示了具有低级特征的跟踪的特征向量。此特征设计的动机基于对典型错误报告的观察。开发人员通常根据一系列操作来识别和描述漏洞。根据我们的经验，这样的序列是描述几何公式或协议等标准概念的合理签名。尽管我们的特征只考虑跟踪中操作符的频率，但每个跟踪都是通过使用复杂的上下文敏感静态分析仔细推导出来的。我们仅在分析器触发警报时才提取跟踪。此外，这些跟踪基于数据流而不是控制流。这些设计选择提高了基于相似性比较的系统的准确性。

​		另一方面，高级特征旨在捕捉更深层次的跟踪上下文。高级特征不是计算运算符的单个出现次数，而是描述表达式和运算符之间的关系。我们将低级特征与高级特征分开设计，以平衡人工工作量和准确性。低级特征包括通用的程序组件，可以在不同的程序之间进行转移，并且不需要手动操作。相反，我们通过观察典型的错误修复模式来手动设计高级特征。例如，`EqualToPercentage`受到通常的条件表达式的启发，用于防止格式字符串漏洞。MVP [47]中也使用了类似的设计选择；他们也特别处理格式字符串。这些高级特征有助于过滤掉典型的误报。在我们的实验中，仅使用低级特征的TRACER的准确性已经相当高，但高级特征可以进一步提高准确性。详细内容将在第5.4节中讨论。

​		TRACER使用余弦相似度，这是一种计算两个向量之间相似性的常见方法。给定两个特征向量$\pi_{1}$和$\pi_{2}$，相似性定义如下： 
$$
\rm{Sim}(\pi_{1},\pi_{2}) =\frac{\pi_{1} \cdot \pi_{2}}{|\pi_{1}|~|\pi_{2}|}
$$

#### 4.3  应用于其他漏洞类型

​		如果底层的分析器产生警报跟踪信息，Tracer的一般原则——计算跟踪之间的相似性分数—适用于其他类型的漏洞。例如，用于检测双重释放（double-free）或使用已释放内存（use-after-free）漏洞的静态分析器通常会报告从调用free函数到其他free调用或使用相同指针的潜在错误跟踪。我们将在下一节中展示对其他漏洞类型的适用性。

### 5  实验

我们的评估旨在回答以下问题：

- RQ1：Tracer在发现未知的重复漏洞方面效果如何？
- RQ2：与现有方法相比，Tracer的准确性如何？
- RQ3：Tracer的高级特性有多有效？
- RQ4：Tracer在大型程序中的可扩展性如何？

​		所有实验都在Linux机器上进行，采用Intel Xeon 2.90GHz处理器。我们将静态分析的超时时间设置为每个软件包一小时。我们的代码和数据可在https://prosys.kaist.ac.kr/tracer/公开获取。

#### 5.1   实验设置

**5.1.1 实现。**我们在Facebook的Infer分析器[5]的基础上实现了Tracer。如前文所述，我们设计了污点分析器。我们使用Infer的缓冲区溢出检查器计算的指针信息。按照Infer的框架，我们的污点分析器被设计为模块化的过程间分析（即，具有上下文敏感性）。对于每个基准测试，我们并行运行20个任务。我们的污点分析检查了第4节中描述的五种常见漏洞：整数溢出、整数下溢、缓冲区溢出、命令注入和格式化字符串错误。我们使用Infer的Pulse引擎来检测使用已释放内存和双重释放漏洞。

**5.1.2 签名程序。**我们从不同来源的真实世界和合成漏洞中收集了签名程序：

**（1）真实世界的漏洞：**我们从CVE报告[10]和之前的研究[20, 21]中收集了16个可以通过我们的污点分析进行复现的漏洞。

**（2）Juliet测试套件[4]：**Juliet测试套件由大量的小程序组成，每个程序都具有一个常见的漏洞。我们使用了5,383个具有与我们分析处理的相同类型漏洞的程序。

**（3）在线教程：**我们从OWASP[16]提供的安全编程在线教程中收集了5个示例。

**5.1.3 基准测试。**我们使用了273个用C/C++编写的Debian软件包来评估Tracer。我们选择了16个常见的Debian软件包类别（web、sound、utils等），其中包含至少一个Infer可以分析的软件包。这一步排除了许多包含不受支持的语言（如R、Haskell等）和在我们的环境中存在构建问题的包的类别。在选定的类别中，我们随机选择了20个至少有一个由我们的分析器引发的警报的软件包。对于包含少于20个软件包的类别，我们使用了该类别中的所有软件包。
